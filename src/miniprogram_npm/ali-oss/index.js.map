{"version":3,"sources":["client.js","../package.json","common/signUtils.js","common/utils/lowercaseKeyHeader.js","common/utils/isObject.js","common/client/initOptions.js","common/utils/checkBucketName.js","common/utils/setRegion.js","common/utils/checkConfigValid.js","common/utils/createRequest.js","common/utils/encoder.js","common/utils/isIP.js","common/client/getReqUrl.js","common/utils/setSTSToken.js","common/utils/formatObjKey.js","common/utils/retry.js","common/object/index.js","common/object/getSymlink.js","common/object/putSymlink.js","common/object/getObjectMeta.js","common/object/copyObject.js","common/object/calculatePostSignature.js","common/utils/policy2Str.js","common/object/getObjectTagging.js","common/object/putObjectTagging.js","common/utils/obj2xml.js","common/utils/checkObjectTag.js","common/utils/checkValid.js","common/object/deleteObjectTagging.js","common/object/getBucketVersions.js","common/utils/isArray.js","common/object/deleteMulti.js","common/object/getACL.js","common/object/putACL.js","common/object/head.js","common/object/delete.js","common/object/get.js","common/object/postAsyncFetch.js","common/object/getAsyncFetch.js","common/object/generateObjectUrl.js","common/object/getObjectUrl.js","common/object/signatureUrl.js","object.js","common/callback.js","common/utils/isBuffer.js","common/image/index.js","common/image/processObjectSave.js","common/bucket/index.js","common/bucket/getBucketRequestPayment.js","common/bucket/putBucketRequestPayment.js","common/bucket/putBucketEncryption.js","common/bucket/getBucketEncryption.js","common/bucket/deleteBucketEncryption.js","common/bucket/getBucketTags.js","common/utils/formatTag.js","common/bucket/putBucketTags.js","common/utils/checkBucketTag.js","common/bucket/deleteBucketTags.js","common/bucket/putBucket.js","common/bucket/getBucketWebsite.js","common/bucket/putBucketWebsite.js","common/bucket/deleteBucketWebsite.js","common/bucket/getBucketLifecycle.js","common/bucket/putBucketLifecycle.js","common/utils/deepCopy.js","common/utils/getStrBytesCount.js","common/bucket/deleteBucketLifecycle.js","common/bucket/getBucketPolicy.js","common/bucket/putBucketPolicy.js","common/bucket/deleteBucketPolicy.js","common/bucket/getBucketVersioning.js","common/bucket/putBucketVersioning.js","common/bucket/getBucketInventory.js","common/utils/formatInventoryConfig.js","common/utils/dataFix.js","common/bucket/deleteBucketInventory.js","common/bucket/listBucketInventory.js","common/bucket/putBucketInventory.js","common/bucket/abortBucketWorm.js","common/bucket/completeBucketWorm.js","common/bucket/extendBucketWorm.js","common/bucket/getBucketWorm.js","common/bucket/initiateBucketWorm.js","bucket.js","managed-upload.js","common/utils/isFile.js","rtmp.js","common/multipart-copy.js","common/parallel.js","common/multipart.js","image.js","cluster.js","sts.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AKfA,AHSA,AENA,ADGA;AFOA,ADGA,AKfA,AHSA,AENA,ADGA;AFOA,ADGA,AKfA,AHSA,AENA,ADGA;AFOA,ADGA,AKfA,AHSA,AIZA,AFMA,ADGA;AFOA,ADGA,AKfA,AHSA,AIZA,AHSA;AFOA,ADGA,AKfA,AHSA,AIZA,AHSA;AFOA,ADGA,AKfA,AHSA,AIZA,AHSA,AIZA;ANmBA,ADGA,AKfA,AHSA,AIZA,AHSA,AIZA;ANmBA,ADGA,AKfA,AHSA,AIZA,AHSA,AIZA;ANmBA,ADGA,AKfA,AHSA,AIZA,AENA,ADGA;ANmBA,ADGA,AKfA,AHSA,AIZA,AENA,ADGA;ANmBA,ADGA,AKfA,AHSA,AIZA,AENA,ADGA;ANmBA,ADGA,AKfA,AHSA,AIZA,AENA,ACHA,AFMA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,AFMA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,AFMA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,AHSA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,AHSA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,AHSA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AKfA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA;ANmBA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,ACHA,ACHA,AJYA,AMlBA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AENA,AJYA,AMlBA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AENA,AJYA,AMlBA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AENA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AENA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AENA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AIZA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AIZA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AHSA,AMlBA,ACHA,AKfA,AHSA,AIZA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AWjCA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AWjCA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AWjCA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,Ad0CA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,AENA,AhBgDA,AMlBA,ACHA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AYpCA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ac1CA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ac1CA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ac1CA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ae7CA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ae7CA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,Ae7CA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA,AFMA;AZqCA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,ACHA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AFMA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,ADGA,AENA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,ADGA,AQxBA,ANkBA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,ADGA,AQxBA,ANkBA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ANkBA,AOrBA,ANkBA,AhBgDA,AOrBA,AKfA,AQxBA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AOrBA,AKfA,AWjCA,AHSA,APqBA;Ad2CA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AOrBA,AKfA,AWjCA,AHSA;ArBgEA,ADGA,AYpCA,APqBA,AgBhDA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AOrBA,AKfA,AWjCA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AwBxEA,AjBmDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AwBxEA,AjBmDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,ADGA,AIZA,ACHA,ANkBA,AhBgDA,AwBxEA,AjBmDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AGTA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AGTA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AGTA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AQxBA,ALeA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AQxBA,ALeA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AQxBA,ALeA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AQxBA,ACHA,ANkBA,ACHA,ANkBA,AhBgDA,AwBxEA,ACHA,AlBsDA,AgBhDA,AHSA;ArBgEA,ADGA,AYpCA,AS3BA,ADGA,AQxBA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AgBhDA;AxByEA,ADGA,AqB/DA,ADGA,AQxBA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AgBhDA;AxByEA,ADGA,AqB/DA,ADGA,AQxBA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AQxBA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AQxBA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,ACHA,ANkBA,ACHA,AtBkEA,AwBxEA,ACHA,AlBsDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,AIZA,AHSA,ANkBA,ACHA,AtBkEA,AwBxEA,AjBmDA,AqB/DA,ALeA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,AIZA,AHSA,ANkBA,ACHA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,AIZA,AHSA,ANkBA,ACHA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AqB/DA,ADGA,AWjCA,AHSA,AIZA,AHSA,ANkBA,AU9BA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,AWjCA,AHSA,AIZA,AHSA,ANkBA,AU9BA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,AWjCA,AHSA,AIZA,AHSA,ANkBA,AU9BA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,AWjCA,AHSA,AIZA,AHSA,ANkBA,AWjCA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,AWjCA,AHSA,AIZA,AHSA,ANkBA,AWjCA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,AWjCA,AHSA,AIZA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AHSA,AIZA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AHSA,AIZA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AHSA,AIZA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AHSA,AQxBA,AJYA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AHSA,AQxBA,AJYA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AHSA,AKfA,ADGA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AHSA,AKfA,AGTA,AJYA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AHSA,AKfA,AGTA,AJYA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AHSA,AKfA,AGTA,AJYA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,AT2BA,AtBkEA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AKfA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AKfA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA,AgBhDA;AxByEA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA;ARyBA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,A/B6FA,AwBxEA,AjBmDA;ARyBA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,AQxBA,AvCqHA,AwBxEA,AjBmDA;ARyBA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,AQxBA,AvCqHA,AwBxEA,AjBmDA;ARyBA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,AQxBA,AvCqHA,AwBxEA,AjBmDA;ARyBA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AJYA,AMlBA,AT2BA,AWjCA,ANkBA,AGTA,AJYA,AQxBA,AvCqHA,AwBxEA,AjBmDA,AiCnGA;AzC4HA,ADGA,AoB5DA,Ae7CA,AJYA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,AwBxEA,AjBmDA,AiCnGA;AzC4HA,ADGA,AoB5DA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,AwBxEA,AgBhDA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AvBqEA,AWjCA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,Ad0CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,Ad0CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,Ad0CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,ACHA,Af6CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,ANkBA,AGTA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,ACHA,Af6CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,AHSA,AIZA,AvCqHA,A0C9HA,AFMA;AzC4HA,ADGA,A2CjIA,AENA,ACHA,Af6CA,AQxBA,AHSA,AENA,AT2BA,AWjCA,AHSA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A+C7IA,AJYA,AGTA,Af6CA,AQxBA,AHSA,APqBA,AWjCA,AHSA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A+C7IA,AJYA,AGTA,Af6CA,AQxBA,AHSA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,A+C7IA,AJYA,AGTA,Af6CA,AQxBA,AHSA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AJYA,AGTA,Af6CA,AQxBA,AHSA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AJYA,AGTA,Af6CA,AQxBA,AHSA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AJYA,AGTA,Af6CA,AKfA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AENA,ANkBA,AGTA,Af6CA,AKfA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AENA,ANkBA,AGTA,Af6CA,AKfA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AENA,ANkBA,AGTA,Af6CA,AKfA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AGTA,ADGA,ANkBA,AGTA,Af6CA,AKfA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AgDhJA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AmDzJA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AmDzJA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AmDzJA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AQxBA,AIZA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,ADGA,AGTA,ADGA,ANkBA,AGTA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,AYpCA,AvCqHA,AwCxHA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,AYpCA,AvCqHA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,AYpCA,AvCqHA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AHSA,AV8BA,APqBA,A3BiFA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AoD5JA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AHSA,AKfA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,ADGA,AENA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,ANkBA,AENA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,ANkBA,AENA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AV8BA,APqBA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,ANkBA,AENA,ANkBA,AGTA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,ANkBA,AENA,ANkBA,AWjCA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,AJYA,AKfA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AoD5JA,AKfA,AJYA,AKfA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AT2BA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AKfA,Ad0CA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AKfA,Ad0CA,AjBmDA,A3BiFA,AsDlKA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AJYA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AKfA,A/B6FA,A2BjFA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AIZA,ARwBA,AMlBA,ADGA,ARwBA,ADGA,AMlBA,AKfA,A/B6FA,A2BjFA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AIZA,AFMA,ADGA,ARwBA,ADGA,AMlBA,AKfA,A/B6FA,A2BjFA,AFMA,AZoCA;AzC4HA,ADGA,AyD3KA,AIZA,AFMA,ADGA,ARwBA,ADGA,AMlBA,AKfA,A/B6FA,A2BjFA,Ad0CA;AzC4HA,ADGA,AyD3KA,AIZA,ACHA,AHSA,ADGA,ARwBA,ADGA,AMlBA,AKfA,A/B6FA,A2BjFA,Ad0CA;AzC4HA,ADGA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AT2BA,AMlBA,AKfA,A/B6FA,A2BjFA,Ad0CA;AzC4HA,ADGA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AT2BA,AMlBA,AKfA,A/B6FA,A2BjFA,Ad0CA;AzC4HA,ADGA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,Ad0CA;A1C+HA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,Ad0CA;A1C+HA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,Ad0CA;A1C+HA,AyD3KA,AIZA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,AQxBA,AtBkEA;A1C+HA,A6DvLA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,AQxBA,AtBkEA;A1C+HA,A6DvLA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,AQxBA,AtBkEA;A1C+HA,A6DvLA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,A6DvLA,ACHA,AHSA,ADGA,AKfA,Ad0CA,AMlBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,A8D1LA,AHSA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AHSA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AHSA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AHSA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,ARwBA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,ARwBA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,ARwBA,ADGA,AKfA,ARwBA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,ARwBA,ADGA,AKfA,AKfA,AbuCA,AKfA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,ARwBA,ADGA,AKfA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AJYA,AKfA,AJYA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AGTA,APqBA,AKfA,AJYA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AGTA,APqBA,AKfA,AJYA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AGTA,APqBA,AKfA,AJYA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AGTA,APqBA,AKfA,AGTA,APqBA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AkEtMA,AGTA,APqBA,AKfA,AGTA,APqBA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AqE/MA,APqBA,AKfA,AGTA,APqBA,AKfA,ARwBA,AJYA,AQxBA,ACHA,AvBqEA;A1C+HA,AqE/MA,APqBA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AJYA,AQxBA,AtBkEA;A1C+HA,AqE/MA,APqBA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AJYA,AQxBA,AtBkEA;A1C+HA,AqE/MA,APqBA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AJYA,AQxBA,AtBkEA;A1C+HA,AqE/MA,AGTA,AV8BA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AJYA,AQxBA,AtBkEA;A1C+HA,AqE/MA,AGTA,AV8BA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AJYA,AQxBA,AtBkEA;A1C+HA,AqE/MA,AGTA,AV8BA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AIZA,AtBkEA;A1C+HA,AqE/MA,AGTA,AV8BA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AIZA,AS3BA,A/B6FA;A1C+HA,AqE/MA,AGTA,AV8BA,AKfA,AGTA,APqBA,AKfA,AGTA,AXiCA,AIZA,AS3BA,A/B6FA;A1C+HA,AqE/MA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,AIZA,AS3BA,A/B6FA;A1C+HA,AqE/MA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,AqE/MA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,AqE/MA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,ANkBA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,ANkBA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,ANkBA,AGTA,ALeA,AGTA,APqBA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,ANkBA,AGTA,ALeA,AGTA,AMlBA,AbuCA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,AHSA,ALeA,AGTA,AMlBA,AbuCA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,AHSA,AFMA,AMlBA,AbuCA,AKfA,AGTA,AXiCA,Ac1CA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,AHSA,AFMA,AMlBA,ACHA,Ad0CA,AKfA,AGTA,AGTA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,AHSA,AFMA,AMlBA,ACHA,Ad0CA,AQxBA,AGTA,AV8BA,AS3BA,A/B6FA;A1C+HA,A2EjOA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,AV8BA,AS3BA,A/B6FA;A1C+HA,A8E1OA,AHSA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,AHSA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,AHSA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AHSA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ARwBA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ARwBA,AIZA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,AJYA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ACHA,ALeA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ACHA,ALeA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ACHA,ALeA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,AJYA,AKfA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;A1C+HA,A8E1OA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AQxBA,AGTA,ADGA,A/B6FA;AyC1HA,AnFyPA,A+E7OA,ACHA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,A/B6FA;AyC1HA,AnFyPA,A+E7OA,ACHA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,A/B6FA;AyC1HA,AnFyPA,A+E7OA,ACHA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,A/B6FA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AWjCA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AWjCA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AWjCA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ANkBA,ACHA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA;AyC1HA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA,A4CpIA;AHUA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA,A4CpIA;AHUA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AWjCA,ADGA,AYpCA,ADGA,A1C8HA,A4CpIA;AHUA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AwBxEA,AbuCA,ADGA,AYpCA,ADGA,A1C8HA,A4CpIA;AHUA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AwBxEA,AbuCA,ADGA,AWjCA,A1C8HA,A4CpIA;AHUA,AnFyPA,AgFhPA,ACHA,ACHA,ALeA,Ad0CA,AwBxEA,AbuCA,ADGA,AWjCA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,ACHA,Ad0CA,ADGA,AWjCA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,ACHA,Ad0CA,AU9BA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,ACHA,Ad0CA,AU9BA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AU9BA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AU9BA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AU9BA,A1C8HA,A4CpIA;AHUA,AnFyPA,AkFtPA,ALeA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A6EvOA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A6EvOA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA;AHUA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,Ad0CA,AgBhDA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,Ad0CA,Ad0CA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,A5BoFA,AwBxEA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AnFyPA,A2FjRA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AENA,ANkBA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ADGA,AJYA,A1C8HA,A4CpIA,AMlBA;AT4BA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AJYA,AENA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,A1C8HA,A4CpIA;AHUA,AQxBA,AFMA,ALeA,AENA;AHUA,AQxBA,AFMA,ALeA,AENA;AHUA,AQxBA,AFMA,ALeA,AENA;AHUA,AQxBA,AFMA,ALeA,AENA;AHUA,AQxBA,AFMA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,AMlBA,ALeA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst debug = require('debug')('ali-oss');\nconst sendToWormhole = require('stream-wormhole');\nconst xml = require('xml2js');\nconst AgentKeepalive = require('agentkeepalive');\nconst HttpsAgentKeepalive = require('agentkeepalive').HttpsAgent;\nconst merge = require('merge-descriptors');\nconst platform = require('platform');\nconst utility = require('utility');\nconst urllib = require('urllib');\nconst pkg = require('../package.json');\nconst bowser = require('bowser');\nconst signUtils = require('./common/signUtils');\nconst _initOptions = require('./common/client/initOptions');\nconst { createRequest } = require('./common/utils/createRequest');\nconst { encoder } = require('./common/utils/encoder');\nconst { getReqUrl } = require('./common/client/getReqUrl');\nconst { setSTSToken } = require('./common/utils/setSTSToken');\nconst { retry } = require('./common/utils/retry');\n\nconst globalHttpAgent = new AgentKeepalive();\nconst globalHttpsAgent = new HttpsAgentKeepalive();\n\nfunction Client(options, ctx) {\n  if (!(this instanceof Client)) {\n    return new Client(options, ctx);\n  }\n\n  if (options && options.inited) {\n    this.options = options;\n  } else {\n    this.options = Client.initOptions(options);\n  }\n\n  // support custom agent and urllib client\n  if (this.options.urllib) {\n    this.urllib = this.options.urllib;\n  } else {\n    this.urllib = urllib;\n    this.agent = this.options.agent || globalHttpAgent;\n    this.httpsAgent = this.options.httpsAgent || globalHttpsAgent;\n  }\n  this.ctx = ctx;\n  this.userAgent = this._getUserAgent();\n}\n\n/**\n * Expose `Client`\n */\n\nmodule.exports = Client;\n\nClient.initOptions = function initOptions(options) {\n  return _initOptions(options);\n};\n\n/**\n * prototype\n */\n\nconst proto = Client.prototype;\n\n/**\n * Object operations\n */\nmerge(proto, require('./common/object'));\nmerge(proto, require('./object'));\nmerge(proto, require('./common/image'));\n/**\n * Bucket operations\n */\nmerge(proto, require('./common/bucket'));\nmerge(proto, require('./bucket'));\n// multipart upload\nmerge(proto, require('./managed-upload'));\n/**\n * RTMP operations\n */\nmerge(proto, require('./rtmp'));\n\n/**\n * common multipart-copy support node and browser\n */\nmerge(proto, require('./common/multipart-copy'));\n/**\n * Common module parallel\n */\nmerge(proto, require('./common/parallel'));\n/**\n * Multipart operations\n */\nmerge(proto, require('./common/multipart'));\n/**\n * ImageClient class\n */\nClient.ImageClient = require('./image')(Client);\n/**\n * Cluster Client class\n */\nClient.ClusterClient = require('./cluster')(Client);\n\n/**\n * STS Client class\n */\nClient.STS = require('./sts');\n\n/**\n * get OSS signature\n * @param {String} stringToSign\n * @return {String} the signature\n */\nproto.signature = function signature(stringToSign) {\n  debug('authorization stringToSign: %s', stringToSign);\n\n  return signUtils.computeSignature(this.options.accessKeySecret, stringToSign, this.options.headerEncoding);\n};\n\nproto._getReqUrl = getReqUrl;\n\n/**\n * get author header\n *\n * \"Authorization: OSS \" + Access Key Id + \":\" + Signature\n *\n * Signature = base64(hmac-sha1(Access Key Secret + \"\\n\"\n *  + VERB + \"\\n\"\n *  + CONTENT-MD5 + \"\\n\"\n *  + CONTENT-TYPE + \"\\n\"\n *  + DATE + \"\\n\"\n *  + CanonicalizedOSSHeaders\n *  + CanonicalizedResource))\n *\n * @param {String} method\n * @param {String} resource\n * @param {Object} header\n * @return {String}\n *\n * @api private\n */\n\nproto.authorization = function authorization(method, resource, subres, headers) {\n  const stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, {\n    headers,\n    parameters: subres\n  });\n\n  return signUtils.authorization(this.options.accessKeyId, this.options.accessKeySecret, stringToSign, this.options.headerEncoding);\n};\n\n/**\n * request oss server\n * @param {Object} params\n *   - {String} object\n *   - {String} bucket\n *   - {Object} [headers]\n *   - {Object} [query]\n *   - {Buffer} [content]\n *   - {Stream} [stream]\n *   - {Stream} [writeStream]\n *   - {String} [mime]\n *   - {Boolean} [xmlResponse]\n *   - {Boolean} [customResponse]\n *   - {Number} [timeout]\n *   - {Object} [ctx] request context, default is `this.ctx`\n *\n * @api private\n */\n\nproto.request = async function (params) {\n  const isAvailableStream = params.stream ? params.stream.readable : true;\n  if (this.options.retryMax && isAvailableStream) {\n    this.request = retry(request.bind(this), this.options.retryMax, {\n      errorHandler: (err) => {\n        const _errHandle = (_err) => {\n          const statusErr = [-1, -2].includes(_err.status);\n          const requestErrorRetryHandle = this.options.requestErrorRetryHandle || (() => true);\n          return statusErr && requestErrorRetryHandle(_err);\n        };\n        if (_errHandle(err)) return true;\n        return false;\n      }\n    });\n  } else {\n    this.request = request.bind(this);\n  }\n\n  return await this.request(params);\n};\n\nasync function request(params) {\n  const reqParams = createRequest.call(this, params);\n  let result;\n  let reqErr;\n  try {\n    result = await this.urllib.request(reqParams.url, reqParams.params);\n    debug('response %s %s, got %s, headers: %j', params.method, reqParams.url, result.status, result.headers);\n  } catch (err) {\n    reqErr = err;\n  }\n  let err;\n  if (result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1) {\n    err = await this.requestError(result);\n    err.params = params;\n  } else if (reqErr) {\n    err = await this.requestError(reqErr);\n  }\n\n  if (err) {\n    if (params.customResponse && result && result.res) {\n      // consume the response stream\n      await sendToWormhole(result.res);\n    }\n\n    if (err.status === 403 && err.code === 'InvalidAccessKeyId' &&\n      this.options.accessKeyId.startsWith('STS.') &&\n      typeof this.options.refreshSTSToken === 'function') {\n      // prevent infinite loop, only trigger once within 10 seconds\n      if (!this._setOptions || Date.now() - this._setOptions > 10000) {\n        this._setOptions = Date.now();\n        await setSTSToken.call(this);\n        return this.request(params);\n      }\n    }\n\n    if (err.name === 'ResponseTimeoutError') {\n      err.message = `${err.message.split(',')[0]}, please increase the timeout or use multipartDownload.`;\n    }\n    throw err;\n  }\n\n  if (params.xmlResponse) {\n    result.data = await this.parseXML(result.data);\n  }\n  return result;\n};\n\nproto._getResource = function _getResource(params) {\n  let resource = '/';\n  if (params.bucket) resource += `${params.bucket}/`;\n  if (params.object) resource += encoder(params.object, this.options.headerEncoding);\n\n  return resource;\n};\n\nproto._escape = function _escape(name) {\n  return utility.encodeURIComponent(name).replace(/%2F/g, '/');\n};\n\n/*\n * Get User-Agent for browser & node.js\n * @example\n *   aliyun-sdk-nodejs/4.1.2 Node.js 5.3.0 on Darwin 64-bit\n *   aliyun-sdk-js/4.1.2 Safari 9.0 on Apple iPhone(iOS 9.2.1)\n *   aliyun-sdk-js/4.1.2 Chrome 43.0.2357.134 32-bit on Windows Server 2008 R2 / 7 64-bit\n */\n\nproto._getUserAgent = function _getUserAgent() {\n  const agent = (process && process.browser) ? 'js' : 'nodejs';\n  const sdk = `aliyun-sdk-${agent}/${pkg.version}`;\n  let plat = platform.description;\n  if (!plat && process) {\n    plat = `Node.js ${process.version.slice(1)} on ${process.platform} ${process.arch}`;\n  }\n\n  return this._checkUserAgent(`${sdk} ${plat}`);\n};\n\nproto._checkUserAgent = function _checkUserAgent(ua) {\n  const userAgent = ua.replace(/\\u03b1/, 'alpha').replace(/\\u03b2/, 'beta');\n  return userAgent;\n};\n\n/*\n * Check Browser And Version\n * @param {String} [name] browser name: like IE, Chrome, Firefox\n * @param {String} [version] browser major version: like 10(IE 10.x), 55(Chrome 55.x), 50(Firefox 50.x)\n * @return {Bool} true or false\n * @api private\n */\n\nproto.checkBrowserAndVersion = function checkBrowserAndVersion(name, version) {\n  return ((bowser.name === name) && (bowser.version.split('.')[0] === version));\n};\n\n/**\n * thunkify xml.parseString\n * @param {String|Buffer} str\n *\n * @api private\n */\n\nproto.parseXML = function parseXMLThunk(str) {\n  return new Promise((resolve, reject) => {\n    if (Buffer.isBuffer(str)) {\n      str = str.toString();\n    }\n    xml.parseString(str, {\n      explicitRoot: false,\n      explicitArray: false\n    }, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n};\n\n/**\n * generater a request error with request response\n * @param {Object} result\n *\n * @api private\n */\n\nproto.requestError = async function requestError(result) {\n  let err = null;\n  if (result.name === 'ResponseTimeoutError') {\n    err = new Error(result.message);\n    err.name = result.name;\n  } else if (!result.data || !result.data.length) {\n    if (result.status === -1 || result.status === -2) { // -1 is net error , -2 is timeout\n      err = new Error(result.message);\n      err.name = result.name;\n      err.status = result.status;\n      err.code = result.name;\n    } else {\n      // HEAD not exists resource\n      if (result.status === 404) {\n        err = new Error('Object not exists');\n        err.name = 'NoSuchKeyError';\n        err.status = 404;\n        err.code = 'NoSuchKey';\n      } else if (result.status === 412) {\n        err = new Error('Pre condition failed');\n        err.name = 'PreconditionFailedError';\n        err.status = 412;\n        err.code = 'PreconditionFailed';\n      } else {\n        err = new Error(`Unknow error, status: ${result.status}`);\n        err.name = 'UnknowError';\n        err.status = result.status;\n      }\n      err.requestId = result.headers['x-oss-request-id'];\n      err.host = '';\n    }\n  } else {\n    const message = String(result.data);\n    debug('request response error data: %s', message);\n\n    let info;\n    try {\n      info = await this.parseXML(message) || {};\n    } catch (error) {\n      debug(message);\n      error.message += `\\nraw xml: ${message}`;\n      error.status = result.status;\n      error.requestId = result.headers['x-oss-request-id'];\n      return error;\n    }\n\n    let msg = info.Message || (`unknow request error, status: ${result.status}`);\n    if (info.Condition) {\n      msg += ` (condition: ${info.Condition})`;\n    }\n    err = new Error(msg);\n    err.name = info.Code ? `${info.Code}Error` : 'UnknowError';\n    err.status = result.status;\n    err.code = info.Code;\n    err.requestId = info.RequestId;\n    err.hostId = info.HostId;\n  }\n\n  debug('generate error %j', err);\n  return err;\n};\n\nproto.setSLDEnabled = function setSLDEnabled(enable) {\n  this.options.sldEnable = !!enable;\n  return this;\n};\n","module.exports = {\n  \"_args\": [\n    [\n      \"ali-oss@6.13.2\",\n      \"/Users/ethan/WeChatProjects/miniprogram-boilerplate\"\n    ]\n  ],\n  \"_from\": \"ali-oss@6.13.2\",\n  \"_id\": \"ali-oss@6.13.2\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-85z+2Cd3ydCmdw/l6oFkaMmyswPVXm2r6a8GI+738s7O6YsDHDSogQ04joymUT2gdFNVWHYWTmXWLKEkD19eEQ==\",\n  \"_location\": \"/ali-oss\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"version\",\n    \"registry\": true,\n    \"raw\": \"ali-oss@6.13.2\",\n    \"name\": \"ali-oss\",\n    \"escapedName\": \"ali-oss\",\n    \"rawSpec\": \"6.13.2\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"6.13.2\"\n  },\n  \"_requiredBy\": [\n    \"/\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/ali-oss/-/ali-oss-6.13.2.tgz\",\n  \"_spec\": \"6.13.2\",\n  \"_where\": \"/Users/ethan/WeChatProjects/miniprogram-boilerplate\",\n  \"author\": {\n    \"name\": \"dead_horse\"\n  },\n  \"browser\": {\n    \"lib/client.js\": \"./dist/aliyun-oss-sdk.js\",\n    \"mime\": \"mime/lite\",\n    \"urllib\": \"./shims/xhr.js\",\n    \"utility\": \"./shims/utility.js\",\n    \"crypto\": \"./shims/crypto/crypto.js\",\n    \"debug\": \"./shims/debug\",\n    \"fs\": false,\n    \"child_process\": false,\n    \"is-type-of\": \"./shims/is-type-of.js\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/aliyun/oss-nodejs-sdk/issues\"\n  },\n  \"dependencies\": {\n    \"address\": \"^1.0.0\",\n    \"agentkeepalive\": \"^3.4.1\",\n    \"bowser\": \"^1.6.0\",\n    \"co-defer\": \"^1.0.0\",\n    \"copy-to\": \"^2.0.1\",\n    \"dateformat\": \"^2.0.0\",\n    \"debug\": \"^2.2.0\",\n    \"destroy\": \"^1.0.4\",\n    \"end-or-error\": \"^1.0.1\",\n    \"get-ready\": \"^1.0.0\",\n    \"humanize-ms\": \"^1.2.0\",\n    \"is-type-of\": \"^1.0.0\",\n    \"js-base64\": \"^2.5.2\",\n    \"jstoxml\": \"^0.2.3\",\n    \"merge-descriptors\": \"^1.0.1\",\n    \"mime\": \"^2.4.5\",\n    \"mz-modules\": \"^2.1.0\",\n    \"platform\": \"^1.3.1\",\n    \"pump\": \"^3.0.0\",\n    \"sdk-base\": \"^2.0.1\",\n    \"stream-http\": \"2.8.2\",\n    \"stream-wormhole\": \"^1.0.4\",\n    \"urllib\": \"^2.33.1\",\n    \"utility\": \"^1.8.0\",\n    \"xml2js\": \"^0.4.16\"\n  },\n  \"description\": \"aliyun oss(object storage service) node client\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.11.6\",\n    \"@babel/plugin-transform-regenerator\": \"^7.10.4\",\n    \"@babel/plugin-transform-runtime\": \"^7.11.5\",\n    \"@babel/preset-env\": \"^7.11.5\",\n    \"@babel/runtime\": \"^7.11.2\",\n    \"@types/node\": \"^14.0.12\",\n    \"@typescript-eslint/eslint-plugin\": \"^2.34.0\",\n    \"@typescript-eslint/parser\": \"^2.34.0\",\n    \"aliasify\": \"^2.0.0\",\n    \"autod\": \"^2.6.1\",\n    \"babelify\": \"^10.0.0\",\n    \"beautify-benchmark\": \"^0.2.4\",\n    \"benchmark\": \"^2.1.1\",\n    \"bluebird\": \"^3.1.5\",\n    \"browserify\": \"^16.5.2\",\n    \"co-fs\": \"^1.2.0\",\n    \"co-mocha\": \"^1.2.1\",\n    \"core-js\": \"^3.6.5\",\n    \"crypto-js\": \"^3.1.9-1\",\n    \"dotenv\": \"^8.2.0\",\n    \"eslint\": \"^6.8.0\",\n    \"eslint-config-airbnb\": \"^16.1.0\",\n    \"eslint-config-ali\": \"^9.0.2\",\n    \"eslint-plugin-import\": \"^2.21.1\",\n    \"eslint-plugin-jsx-a11y\": \"^6.0.3\",\n    \"eslint-plugin-react\": \"^7.7.0\",\n    \"filereader\": \"^0.10.3\",\n    \"git-pre-hooks\": \"^1.2.0\",\n    \"immediate\": \"^3.3.0\",\n    \"karma\": \"^1.7.1\",\n    \"karma-browserify\": \"^5.1.1\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-firefox-launcher\": \"^1.0.1\",\n    \"karma-ie-launcher\": \"^1.0.0\",\n    \"karma-mocha\": \"^1.3.0\",\n    \"karma-safari-launcher\": \"^1.0.0\",\n    \"lint-staged\": \"^9.5.0\",\n    \"mm\": \"^2.0.0\",\n    \"mocha\": \"^3.5.3\",\n    \"nyc\": \"^13.3.0\",\n    \"promise-polyfill\": \"^6.0.2\",\n    \"request\": \"^2.88.0\",\n    \"should\": \"^11.0.0\",\n    \"sinon\": \"^1.17.7\",\n    \"snyk\": \"^1.231.0\",\n    \"standard-version\": \"^8.0.1\",\n    \"stream-equal\": \"^1.1.0\",\n    \"thunk-mocha\": \"^1.0.3\",\n    \"timemachine\": \"^0.3.0\",\n    \"typescript\": \"^3.9.5\",\n    \"uglify-js\": \"^2.8.29\",\n    \"watchify\": \"^3.9.0\"\n  },\n  \"engines\": {\n    \"node\": \">=8\"\n  },\n  \"files\": [\n    \"lib\",\n    \"shims\",\n    \"dist\"\n  ],\n  \"git-pre-hooks\": {\n    \"pre-release\": \"npm run build-dist\",\n    \"post-release\": [\n      \"npm run publish-to-npm\",\n      \"npm run publish-to-cdn\"\n    ],\n    \"pre-commit\": \"npm run lint-staged\"\n  },\n  \"homepage\": \"https://github.com/aliyun/oss-nodejs-sdk\",\n  \"keywords\": [\n    \"oss\",\n    \"client\",\n    \"file\",\n    \"aliyun\"\n  ],\n  \"license\": \"MIT\",\n  \"lint-staged\": {\n    \"**/!(dist)/*\": [\n      \"npm run detect-secrets --\"\n    ]\n  },\n  \"main\": \"lib/client.js\",\n  \"name\": \"ali-oss\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/aliyun/oss-nodejs-sdk.git\"\n  },\n  \"scripts\": {\n    \"autod\": \"autod\",\n    \"browser-test\": \"npm run build-test && karma start\",\n    \"build-change-log\": \"standard-version\",\n    \"build-dist\": \"npm run tsc && node browser-build.js > dist/aliyun-oss-sdk.js && MINIFY=1 node browser-build.js > dist/aliyun-oss-sdk.min.js\",\n    \"build-test\": \"MINIFY=1 node browser-build.js > test/browser/build/aliyun-oss-sdk.min.js && node -r dotenv/config task/browser-test-build.js > test/browser/build/tests.js\",\n    \"detect-secrets\": \"node task/detect-secrets\",\n    \"jshint\": \"jshint .\",\n    \"lint-staged\": \"lint-staged\",\n    \"prepublish\": \"npm run snyk-protect\",\n    \"publish-to-cdn\": \"node publish.js\",\n    \"publish-to-npm\": \"node publish-npm-check.js && npm publish\",\n    \"snyk-protect\": \"snyk protect\",\n    \"test\": \"mocha -t 60000 -r thunk-mocha -r should -r dotenv/config test/node/*.test.js test/node/**/*.test.js\",\n    \"test-cov\": \"nyc --reporter=lcov node_modules/.bin/_mocha -t 60000 -r thunk-mocha -r should test/node/*.test.js test/node/**/*.test.js\",\n    \"tsc\": \"npm run tsc:clean && npm run tsc:build\",\n    \"tsc:build\": \"tsc -b tsconfig.json tsconfig-cjs.json\",\n    \"tsc:clean\": \"tsc -b tsconfig.json tsconfig-cjs.json --clean \",\n    \"tsc:watch\": \"tsc -b tsconfig.json tsconfig-cjs.json --watch\"\n  },\n  \"snyk\": true,\n  \"version\": \"6.13.2\"\n}\n","\nconst crypto = require('crypto');\nconst is = require('is-type-of');\nconst { lowercaseKeyHeader } = require('./utils/lowercaseKeyHeader')\n\n/**\n *\n * @param {String} resourcePath\n * @param {Object} parameters\n * @return\n */\nexports.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {\n  let canonicalizedResource = `${resourcePath}`;\n  let separatorString = '?';\n\n  if (is.string(parameters) && parameters.trim() !== '') {\n    canonicalizedResource += separatorString + parameters;\n  } else if (is.array(parameters)) {\n    parameters.sort();\n    canonicalizedResource += separatorString + parameters.join('&');\n  } else if (parameters) {\n    const compareFunc = (entry1, entry2) => {\n      if (entry1[0] > entry2[0]) {\n        return 1;\n      } else if (entry1[0] < entry2[0]) {\n        return -1;\n      }\n      return 0;\n    };\n    const processFunc = (key) => {\n      canonicalizedResource += separatorString + key;\n      if (parameters[key]) {\n        canonicalizedResource += `=${parameters[key]}`;\n      }\n      separatorString = '&';\n    };\n    Object.keys(parameters).sort(compareFunc).forEach(processFunc);\n  }\n\n  return canonicalizedResource;\n};\n\n/**\n * @param {String} method\n * @param {String} resourcePath\n * @param {Object} request\n * @param {String} expires\n * @return {String} canonicalString\n */\nexports.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {\n  request = request || {};\n  const headers = lowercaseKeyHeader(request.headers);\n  const OSS_PREFIX = 'x-oss-';\n  const ossHeaders = [];\n  const headersToSign = {};\n\n  let signContent = [\n    method.toUpperCase(),\n    headers['content-md5'] || '',\n    headers['content-type'],\n    expires || headers['x-oss-date']\n  ];\n\n  Object.keys(headers).forEach((key) => {\n    const lowerKey = key.toLowerCase();\n    if (lowerKey.indexOf(OSS_PREFIX) === 0) {\n      headersToSign[lowerKey] = String(headers[key]).trim();\n    }\n  });\n\n  Object.keys(headersToSign).sort().forEach((key) => {\n    ossHeaders.push(`${key}:${headersToSign[key]}`);\n  });\n\n  signContent = signContent.concat(ossHeaders);\n\n  signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));\n\n  return signContent.join('\\n');\n};\n\n/**\n * @param {String} accessKeySecret\n * @param {String} canonicalString\n */\nexports.computeSignature = function computeSignature(accessKeySecret, canonicalString, headerEncoding = 'utf-8') {\n  const signature = crypto.createHmac('sha1', accessKeySecret);\n  return signature.update(Buffer.from(canonicalString, headerEncoding)).digest('base64');\n};\n\n/**\n * @param {String} accessKeyId\n * @param {String} accessKeySecret\n * @param {String} canonicalString\n */\nexports.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString, headerEncoding) {\n  return `OSS ${accessKeyId}:${this.computeSignature(accessKeySecret, canonicalString, headerEncoding)}`;\n};\n\n/**\n *\n * @param {String} accessKeySecret\n * @param {Object} options\n * @param {String} resource\n * @param {Number} expires\n */\nexports._signatureForURL = function _signatureForURL(accessKeySecret, options = {}, resource, expires, headerEncoding) {\n  const headers = {};\n  const { subResource = {} } = options;\n\n  if (options.process) {\n    const processKeyword = 'x-oss-process';\n    subResource[processKeyword] = options.process;\n  }\n\n  if (options.trafficLimit) {\n    const trafficLimitKey = 'x-oss-traffic-limit';\n    subResource[trafficLimitKey] = options.trafficLimit;\n  }\n\n  if (options.response) {\n    Object.keys(options.response).forEach((k) => {\n      const key = `response-${k.toLowerCase()}`;\n      subResource[key] = options.response[k];\n    });\n  }\n\n  Object.keys(options).forEach((key) => {\n    const lowerKey = key.toLowerCase();\n    const value = options[key];\n    if (lowerKey.indexOf('x-oss-') === 0) {\n      headers[lowerKey] = value;\n    } else if (lowerKey.indexOf('content-md5') === 0) {\n      headers[key] = value;\n    } else if (lowerKey.indexOf('content-type') === 0) {\n      headers[key] = value;\n    }\n  });\n\n  if (Object.prototype.hasOwnProperty.call(options, 'security-token')) {\n    subResource['security-token'] = options['security-token'];\n  }\n\n  if (Object.prototype.hasOwnProperty.call(options, 'callback')) {\n    const json = {\n      callbackUrl: encodeURI(options.callback.url),\n      callbackBody: options.callback.body\n    };\n    if (options.callback.host) {\n      json.callbackHost = options.callback.host;\n    }\n    if (options.callback.contentType) {\n      json.callbackBodyType = options.callback.contentType;\n    }\n    subResource.callback = Buffer.from(JSON.stringify(json)).toString('base64');\n\n    if (options.callback.customValue) {\n      const callbackVar = {};\n      Object.keys(options.callback.customValue).forEach((key) => {\n        callbackVar[`x:${key}`] = options.callback.customValue[key];\n      });\n      subResource['callback-var'] = Buffer.from(JSON.stringify(callbackVar)).toString('base64');\n    }\n  }\n\n  const canonicalString = this.buildCanonicalString(options.method, resource, {\n    headers,\n    parameters: subResource\n  }, expires.toString());\n\n  return {\n    Signature: this.computeSignature(accessKeySecret, canonicalString, headerEncoding),\n    subResource\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lowercaseKeyHeader = void 0;\nconst isObject_1 = require(\"./isObject\");\nfunction lowercaseKeyHeader(headers) {\n    const lowercaseHeader = {};\n    if (isObject_1.isObject(headers)) {\n        Object.keys(headers).forEach(key => {\n            lowercaseHeader[key.toLowerCase()] = headers[key];\n        });\n    }\n    return lowercaseHeader;\n}\nexports.lowercaseKeyHeader = lowercaseKeyHeader;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isObject = void 0;\nexports.isObject = (obj) => {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n};\n","const ms = require('humanize-ms');\nconst urlutil = require('url');\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { setRegion } = require('../utils/setRegion');\nconst { checkConfigValid } = require('../utils/checkConfigValid');\n\nfunction setEndpoint(endpoint, secure) {\n  checkConfigValid(endpoint, 'endpoint');\n  let url = urlutil.parse(endpoint);\n\n  if (!url.protocol) {\n    url = urlutil.parse(`http${secure ? 's' : ''}://${endpoint}`);\n  }\n\n  if (url.protocol !== 'http:' && url.protocol !== 'https:') {\n    throw new Error('Endpoint protocol must be http or https.');\n  }\n\n  return url;\n}\n\nmodule.exports = function (options) {\n  if (!options\n    || !options.accessKeyId\n    || !options.accessKeySecret) {\n    throw new Error('require accessKeyId, accessKeySecret');\n  }\n  if (options.bucket) {\n    _checkBucketName(options.bucket);\n  }\n  const opts = Object.assign({\n    region: 'oss-cn-hangzhou',\n    internal: false,\n    secure: false,\n    timeout: 60000,\n    bucket: null,\n    endpoint: null,\n    cname: false,\n    isRequestPay: false,\n    sldEnable: false,\n    headerEncoding: 'utf-8',\n    refreshSTSToken: null\n  }, options);\n\n  opts.accessKeyId = opts.accessKeyId.trim();\n  opts.accessKeySecret = opts.accessKeySecret.trim();\n\n  if (opts.timeout) {\n    opts.timeout = ms(opts.timeout);\n  }\n\n  if (opts.endpoint) {\n    opts.endpoint = setEndpoint(opts.endpoint, opts.secure);\n  } else if (opts.region) {\n    opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);\n  } else {\n    throw new Error('require options.endpoint or options.region');\n  }\n\n  opts.inited = true;\n  return opts;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBucketName = void 0;\nexports.checkBucketName = (name, createBucket = false) => {\n    const bucketRegex = createBucket ? /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/ : /^[a-z0-9_][a-z0-9-_]{1,61}[a-z0-9_]$/;\n    if (!bucketRegex.test(name)) {\n        throw new Error('The bucket must be conform to the specifications');\n    }\n};\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setRegion = void 0;\nconst url_1 = __importDefault(require(\"url\"));\nconst checkConfigValid_1 = require(\"./checkConfigValid\");\nfunction setRegion(region, internal = false, secure = false) {\n    checkConfigValid_1.checkConfigValid(region, 'region');\n    const protocol = secure ? 'https://' : 'http://';\n    let suffix = internal ? '-internal.aliyuncs.com' : '.aliyuncs.com';\n    const prefix = 'vpc100-oss-cn-';\n    // aliyun VPC region: https://help.aliyun.com/knowledge_detail/38740.html\n    if (region.substr(0, prefix.length) === prefix) {\n        suffix = '.aliyuncs.com';\n    }\n    return url_1.default.parse(protocol + region + suffix);\n}\nexports.setRegion = setRegion;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkConfigValid = void 0;\nconst checkConfigMap = {\n    endpoint: checkEndpoint,\n    region: /^[a-zA-Z0-9\\-_]+$/,\n};\nfunction checkEndpoint(endpoint) {\n    if (typeof endpoint === 'string') {\n        return /^[a-zA-Z0-9._:/-]+$/.test(endpoint);\n    }\n    else if (endpoint.host) {\n        return /^[a-zA-Z0-9._:/-]+$/.test(endpoint.host);\n    }\n    return false;\n}\nexports.checkConfigValid = (conf, key) => {\n    if (checkConfigMap[key]) {\n        let isConfigValid = true;\n        if (checkConfigMap[key] instanceof Function) {\n            isConfigValid = checkConfigMap[key](conf);\n        }\n        else {\n            isConfigValid = checkConfigMap[key].test(conf);\n        }\n        if (!isConfigValid) {\n            throw new Error(`The ${key} must be conform to the specifications`);\n        }\n    }\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRequest = void 0;\nconst crypto = require('crypto');\nconst debug = require('debug')('ali-oss');\nconst mime = require('mime');\nconst dateFormat = require('dateformat');\nconst copy = require('copy-to');\nconst path = require('path');\nconst { encoder } = require('./encoder');\nconst { isIP } = require('./isIP');\nconst { setRegion } = require('./setRegion');\nconst { getReqUrl } = require('../client/getReqUrl');\nfunction getHeader(headers, name) {\n    return headers[name] || headers[name.toLowerCase()];\n}\nfunction delHeader(headers, name) {\n    delete headers[name];\n    delete headers[name.toLowerCase()];\n}\nfunction createRequest(params) {\n    let date = new Date();\n    if (this.options.amendTimeSkewed) {\n        date = +new Date() + this.options.amendTimeSkewed;\n    }\n    const headers = {\n        'x-oss-date': dateFormat(date, 'UTC:ddd, dd mmm yyyy HH:MM:ss \\'GMT\\''),\n        'x-oss-user-agent': this.userAgent\n    };\n    if (this.userAgent.includes('nodejs')) {\n        headers['User-Agent'] = this.userAgent;\n    }\n    if (this.options.isRequestPay) {\n        Object.assign(headers, { 'x-oss-request-payer': 'requester' });\n    }\n    if (this.options.stsToken) {\n        headers['x-oss-security-token'] = this.options.stsToken;\n    }\n    copy(params.headers).to(headers);\n    if (!getHeader(headers, 'Content-Type')) {\n        if (params.mime && params.mime.indexOf('/') > 0) {\n            headers['Content-Type'] = params.mime;\n        }\n        else {\n            headers['Content-Type'] = mime.getType(params.mime || path.extname(params.object || ''));\n        }\n    }\n    if (!getHeader(headers, 'Content-Type')) {\n        delHeader(headers, 'Content-Type');\n    }\n    if (params.content) {\n        headers['Content-MD5'] = crypto\n            .createHash('md5')\n            .update(Buffer.from(params.content, 'utf8'))\n            .digest('base64');\n        if (!headers['Content-Length']) {\n            headers['Content-Length'] = params.content.length;\n        }\n    }\n    const { hasOwnProperty } = Object.prototype;\n    for (const k in headers) {\n        if (headers[k] && hasOwnProperty.call(headers, k)) {\n            headers[k] = encoder(String(headers[k]), this.options.headerEncoding);\n        }\n    }\n    const authResource = this._getResource(params);\n    headers.authorization = this.authorization(params.method, authResource, params.subres, headers, this.options.headerEncoding);\n    // const url = this._getReqUrl(params);\n    if (isIP(this.options.endpoint.hostname)) {\n        const { region, internal, secure } = this.options;\n        const hostInfo = setRegion(region, internal, secure);\n        headers.host = `${params.bucket}.${hostInfo.host}`;\n    }\n    const url = getReqUrl.bind(this)(params);\n    debug('request %s %s, with headers %j, !!stream: %s', params.method, url, headers, !!params.stream);\n    const timeout = params.timeout || this.options.timeout;\n    const reqParams = {\n        method: params.method,\n        content: params.content,\n        stream: params.stream,\n        headers,\n        timeout,\n        writeStream: params.writeStream,\n        customResponse: params.customResponse,\n        ctx: params.ctx || this.ctx\n    };\n    if (this.agent) {\n        reqParams.agent = this.agent;\n    }\n    if (this.httpsAgent) {\n        reqParams.httpsAgent = this.httpsAgent;\n    }\n    reqParams.enableProxy = !!this.options.enableProxy;\n    reqParams.proxy = this.options.proxy ? this.options.proxy : null;\n    return {\n        url,\n        params: reqParams\n    };\n}\nexports.createRequest = createRequest;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encoder = void 0;\nfunction encoder(str, encoding = 'utf-8') {\n    if (encoding === 'utf-8')\n        return str;\n    return Buffer.from(str).toString('latin1');\n}\nexports.encoder = encoder;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isIP = void 0;\n// it provide commont methods for node and browser , we will add more solutions later in this file\n/**\n * Judge isIP include ipv4 or ipv6\n * @param {String} options\n * @return {Array} the multipart uploads\n */\nexports.isIP = (host) => {\n    const ipv4Regex = /^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$/;\n    const ipv6Regex = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n    return ipv4Regex.test(host) || ipv6Regex.test(host);\n};\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReqUrl = void 0;\nconst copy_to_1 = __importDefault(require(\"copy-to\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst merge_descriptors_1 = __importDefault(require(\"merge-descriptors\"));\nconst is_type_of_1 = __importDefault(require(\"is-type-of\"));\nconst isIP_1 = require(\"../utils/isIP\");\nconst checkConfigValid_1 = require(\"../utils/checkConfigValid\");\nfunction getReqUrl(params) {\n    const ep = {};\n    const isCname = this.options.cname;\n    checkConfigValid_1.checkConfigValid(this.options.endpoint, 'endpoint');\n    copy_to_1.default(this.options.endpoint, false).to(ep);\n    if (params.bucket && !isCname && !isIP_1.isIP(ep.hostname) && !this.options.sldEnable) {\n        ep.host = `${params.bucket}.${ep.host}`;\n    }\n    let resourcePath = '/';\n    if (params.bucket && (this.options.sldEnable)) {\n        resourcePath += `${params.bucket}/`;\n    }\n    if (params.object) {\n        // Preserve '/' in result url\n        resourcePath += this._escape(params.object).replace(/\\+/g, '%2B');\n    }\n    ep.pathname = resourcePath;\n    const query = {};\n    if (params.query) {\n        merge_descriptors_1.default(query, params.query);\n    }\n    if (params.subres) {\n        let subresAsQuery = {};\n        if (is_type_of_1.default.string(params.subres)) {\n            subresAsQuery[params.subres] = '';\n        }\n        else if (is_type_of_1.default.array(params.subres)) {\n            params.subres.forEach((k) => {\n                subresAsQuery[k] = '';\n            });\n        }\n        else {\n            subresAsQuery = params.subres;\n        }\n        merge_descriptors_1.default(query, subresAsQuery);\n    }\n    ep.query = query;\n    return url_1.default.format(ep);\n}\nexports.getReqUrl = getReqUrl;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setSTSToken = void 0;\nconst formatObjKey_1 = require(\"./formatObjKey\");\nasync function setSTSToken() {\n    if (!this.options)\n        this.options = {};\n    let credentials = await this.options.refreshSTSToken();\n    credentials = formatObjKey_1.formatObjKey(credentials, 'firstLowerCase');\n    if (credentials.securityToken) {\n        credentials.stsToken = credentials.securityToken;\n    }\n    checkCredentials(credentials);\n    Object.assign(this.options, credentials);\n}\nexports.setSTSToken = setSTSToken;\nfunction checkCredentials(obj) {\n    const stsTokenKey = ['accessKeySecret', 'accessKeyId', 'stsToken'];\n    const objKeys = Object.keys(obj);\n    stsTokenKey.forEach(_ => {\n        if (!objKeys.find(key => key === _)) {\n            throw Error(`refreshSTSToken must return contains ${_}`);\n        }\n    });\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatObjKey = void 0;\nfunction formatObjKey(obj, type, options) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    let o;\n    if (Array.isArray(obj)) {\n        o = [];\n        for (let i = 0; i < obj.length; i++) {\n            o.push(formatObjKey(obj[i], type, options));\n        }\n    }\n    else {\n        o = {};\n        Object.keys(obj).forEach((key) => {\n            o[handelFormat(key, type, options)] = formatObjKey(obj[key], type, options);\n        });\n    }\n    return o;\n}\nexports.formatObjKey = formatObjKey;\nfunction handelFormat(key, type, options) {\n    var _a;\n    if (options && ((_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(key)))\n        return key;\n    if (type === 'firstUpperCase') {\n        key = key.replace(/^./, (_) => _.toUpperCase());\n    }\n    else if (type === 'firstLowerCase') {\n        key = key.replace(/^./, (_) => _.toLowerCase());\n    }\n    return key;\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retry = void 0;\nfunction retry(func, retryMax, config = {}) {\n    let retryNum = 0;\n    const { retryDelay = 500, errorHandler = () => true } = config;\n    const funcR = (...arg) => {\n        return new Promise((resolve, reject) => {\n            func(...arg)\n                .then(result => {\n                retryNum = 0;\n                resolve(result);\n            })\n                .catch(err => {\n                if (retryNum < retryMax && errorHandler(err)) {\n                    retryNum++;\n                    setTimeout(() => {\n                        resolve(funcR(...arg));\n                    }, retryDelay);\n                }\n                else {\n                    retryNum = 0;\n                    reject(err);\n                }\n            });\n        });\n    };\n    return funcR;\n}\nexports.retry = retry;\n","const merge = require('merge-descriptors');\n\nconst proto = exports;\n\nmerge(proto, require('./getSymlink'));\nmerge(proto, require('./putSymlink'));\nmerge(proto, require('./getObjectMeta'));\nmerge(proto, require('./copyObject'));\nmerge(proto, require('./calculatePostSignature'));\nmerge(proto, require('./getObjectTagging'));\nmerge(proto, require('./putObjectTagging'));\nmerge(proto, require('./deleteObjectTagging'));\nmerge(proto, require('./getBucketVersions'));\nmerge(proto, require('./deleteMulti'));\nmerge(proto, require('./getACL'));\nmerge(proto, require('./putACL'));\nmerge(proto, require('./head'));\nmerge(proto, require('./delete'));\nmerge(proto, require('./get'));\nmerge(proto, require('./postAsyncFetch'));\nmerge(proto, require('./getAsyncFetch'));\nmerge(proto, require('./generateObjectUrl'));\nmerge(proto, require('./getObjectUrl'));\nmerge(proto, require('./signatureUrl'));\n\n","const proto = exports;\n/**\n * getSymlink\n * @param {String} name - object name\n * @param {Object} options\n * @param {{res}}\n */\n\nproto.getSymlink = async function getSymlink(name, options = {}) {\n  options.subres = Object.assign({ symlink: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  name = this._objectName(name);\n  const params = this._objectRequestParams('GET', name, options);\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  const target = result.res.headers['x-oss-symlink-target'];\n  return {\n    targetName: decodeURIComponent(target),\n    res: result.res\n  };\n};\n","const proto = exports;\n/**\n * putSymlink\n * @param {String} name - object name\n * @param {String} targetName - target name\n * @param {Object} options\n * @param {{res}}\n */\n\nproto.putSymlink = async function putSymlink(name, targetName, options) {\n  options = options || {};\n  options.headers = options.headers || {};\n  targetName = this._escape(this._objectName(targetName));\n  this._convertMetaToHeaders(options.meta, options.headers);\n  options.headers['x-oss-symlink-target'] = targetName;\n  options.subres = Object.assign({ symlink: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n\n  if (options.storageClass) {\n    options.headers['x-oss-storage-class'] = options.storageClass;\n  }\n\n  name = this._objectName(name);\n  const params = this._objectRequestParams('PUT', name, options);\n\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n","const proto = exports;\n/**\n * getObjectMeta\n * @param {String} name - object name\n * @param {Object} options\n * @param {{res}}\n */\n\nproto.getObjectMeta = async function getObjectMeta(name, options) {\n  options = options || {};\n  name = this._objectName(name);\n  options.subres = Object.assign({ objectMeta: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('HEAD', name, options);\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n\nconst REPLACE_HEDERS = [\n  'content-type',\n  'content-encoding',\n  'content-language',\n  'content-disposition',\n  'cache-control',\n  'expires',\n];\n\nproto.copy = async function copy(name, sourceName, bucketName, options) {\n  if (typeof bucketName === 'object') {\n    options = bucketName; // 兼容旧版本，旧版本第三个参数为options\n  }\n  options = options || {};\n  options.headers = options.headers || {};\n\n  Object.keys(options.headers).forEach((key) => {\n    options.headers[`x-oss-copy-source-${key.toLowerCase()}`] = options.headers[key];\n  });\n  if (options.meta || Object.keys(options.headers).find(_ => REPLACE_HEDERS.includes(_.toLowerCase()))) {\n    options.headers['x-oss-metadata-directive'] = 'REPLACE';\n  }\n  this._convertMetaToHeaders(options.meta, options.headers);\n\n  sourceName = this._getSourceName(sourceName, bucketName);\n\n  if (options.versionId) {\n    sourceName = `${sourceName}?versionId=${options.versionId}`;\n  }\n\n  options.headers['x-oss-copy-source'] = sourceName;\n\n  const params = this._objectRequestParams('PUT', name, options);\n  params.xmlResponse = true;\n  params.successStatuses = [200, 304];\n\n  const result = await this.request(params);\n\n  let { data } = result;\n  if (data) {\n    data = {\n      etag: data.ETag,\n      lastModified: data.LastModified\n    };\n  }\n\n  return {\n    data,\n    res: result.res\n  };\n};\n\n// todo delete\nproto._getSourceName = function _getSourceName(sourceName, bucketName) {\n  if (typeof bucketName === 'string') {\n    sourceName = this._objectName(sourceName);\n  } else if (sourceName[0] !== '/') {\n    bucketName = this.options.bucket;\n  } else {\n    bucketName = sourceName.replace(/\\/(.+?)(\\/.*)/, '$1');\n    sourceName = sourceName.replace(/(\\/.+?\\/)(.*)/, '$2');\n  }\n\n  _checkBucketName(bucketName);\n\n  sourceName = encodeURIComponent(sourceName);\n\n  sourceName = `/${bucketName}/${sourceName}`;\n  return sourceName;\n};\n","\nconst { policy2Str } = require('../utils/policy2Str');\nconst signHelper = require('../signUtils');\nconst { isObject } = require('../utils/isObject');\n\nconst proto = exports;\n\n/**\n * @param {Object or JSON} policy specifies the validity of the fields in the request.\n * @return {Object} params\n *         {String} params.OSSAccessKeyId\n *         {String} params.Signature\n *         {String} params.policy JSON text encoded with UTF-8 and Base64.\n */\nproto.calculatePostSignature = function calculatePostSignature(policy) {\n  if (!isObject(policy) && typeof policy !== 'string') {\n    throw new Error('policy must be JSON string or Object');\n  }\n  if (!isObject(policy)) {\n    try {\n      JSON.stringify(JSON.parse(policy));\n    } catch (error) {\n      throw new Error('policy must be JSON string or Object');\n    }\n  }\n  policy = Buffer.from(policy2Str(policy), 'utf8').toString('base64');\n\n  const Signature = signHelper.computeSignature(this.options.accessKeySecret, policy);\n\n  const query = {\n    OSSAccessKeyId: this.options.accessKeyId,\n    Signature,\n    policy\n  };\n  return query;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.policy2Str = void 0;\nfunction policy2Str(policy) {\n    let policyStr;\n    if (policy) {\n        if (typeof policy === 'string') {\n            try {\n                policyStr = JSON.stringify(JSON.parse(policy));\n            }\n            catch (err) {\n                throw new Error(`Policy string is not a valid JSON: ${err.message}`);\n            }\n        }\n        else {\n            policyStr = JSON.stringify(policy);\n        }\n    }\n    return policyStr;\n}\nexports.policy2Str = policy2Str;\n","const proto = exports;\nconst { isObject } = require('../utils/isObject');\n/**\n * getObjectTagging\n * @param {String} name - object name\n * @param {Object} options\n * @return {Object}\n */\n\nproto.getObjectTagging = async function getObjectTagging(name, options = {}) {\n  options.subres = Object.assign({ tagging: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  name = this._objectName(name);\n  const params = this._objectRequestParams('GET', name, options);\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  const Tagging = await this.parseXML(result.data);\n  let { Tag } = Tagging.TagSet;\n  Tag = Tag && isObject(Tag) ? [Tag] : Tag || [];\n\n  const tag = {};\n\n  Tag.forEach((item) => {\n    tag[item.Key] = item.Value;\n  });\n\n  return {\n    status: result.status,\n    res: result.res,\n    tag\n  };\n};\n","const { obj2xml } = require('../utils/obj2xml');\nconst { checkObjectTag } = require('../utils/checkObjectTag');\n\nconst proto = exports;\n/**\n * putObjectTagging\n * @param {String} name - object name\n * @param {Object} tag -  object tag, eg: `{a: \"1\", b: \"2\"}`\n * @param {Object} options\n */\n\nproto.putObjectTagging = async function putObjectTagging(name, tag, options = {}) {\n  checkObjectTag(tag);\n\n  options.subres = Object.assign({ tagging: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  name = this._objectName(name);\n  const params = this._objectRequestParams('PUT', name, options);\n  params.successStatuses = [200];\n  tag = Object.keys(tag).map(key => ({\n    Key: key,\n    Value: tag[key]\n  }));\n\n  const paramXMLObj = {\n    Tagging: {\n      TagSet: {\n        Tag: tag\n      }\n    }\n  };\n\n  params.mime = 'xml';\n  params.content = obj2xml(paramXMLObj);\n\n  const result = await this.request(params);\n  return {\n    res: result.res,\n    status: result.status\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.obj2xml = void 0;\nconst formatObjKey_1 = require(\"./formatObjKey\");\nfunction type(params) {\n    return Object.prototype.toString\n        .call(params)\n        .replace(/(.*? |])/g, '')\n        .toLowerCase();\n}\nfunction obj2xml(obj, options) {\n    let s = '';\n    if (options && options.headers) {\n        s = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    }\n    if (options && options.firstUpperCase) {\n        obj = formatObjKey_1.formatObjKey(obj, 'firstUpperCase');\n    }\n    if (type(obj) === 'object') {\n        Object.keys(obj).forEach(key => {\n            // filter undefined or null\n            if (type(obj[key]) !== 'undefined' && type(obj[key]) !== 'null') {\n                if (type(obj[key]) === 'string' || type(obj[key]) === 'number') {\n                    s += `<${key}>${obj[key]}</${key}>`;\n                }\n                else if (type(obj[key]) === 'object') {\n                    s += `<${key}>${obj2xml(obj[key])}</${key}>`;\n                }\n                else if (type(obj[key]) === 'array') {\n                    s += obj[key]\n                        .map(keyChild => `<${key}>${obj2xml(keyChild)}</${key}>`)\n                        .join('');\n                }\n                else {\n                    s += `<${key}>${obj[key].toString()}</${key}>`;\n                }\n            }\n        });\n    }\n    else {\n        s += obj.toString();\n    }\n    return s;\n}\nexports.obj2xml = obj2xml;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkObjectTag = void 0;\nconst { checkValid } = require('./checkValid');\nconst { isObject } = require('./isObject');\nconst commonRules = [\n    {\n        validator: (value) => {\n            if (typeof value !== 'string') {\n                throw new Error('the key and value of the tag must be String');\n            }\n        }\n    },\n    {\n        pattern: /^[a-zA-Z0-9 +-=._:/]+$/,\n        msg: 'tag can contain letters, numbers, spaces, and the following symbols: plus sign (+), hyphen (-), equal sign (=), period (.), underscore (_), colon (:), and forward slash (/)'\n    }\n];\nconst rules = {\n    key: [\n        ...commonRules,\n        {\n            pattern: /^.{1,128}$/,\n            msg: 'tag key can be a maximum of 128 bytes in length'\n        }\n    ],\n    value: [\n        ...commonRules,\n        {\n            pattern: /^.{0,256}$/,\n            msg: 'tag value can be a maximum of 256 bytes in length'\n        }\n    ]\n};\nfunction checkObjectTag(tag) {\n    if (!isObject(tag)) {\n        throw new Error('tag must be Object');\n    }\n    const entries = Object.entries(tag);\n    if (entries.length > 10) {\n        throw new Error('maximum of 10 tags for a object');\n    }\n    const rulesIndexKey = ['key', 'value'];\n    entries.forEach((keyValue) => {\n        keyValue.forEach((item, index) => {\n            checkValid(item, rules[rulesIndexKey[index]]);\n        });\n    });\n}\nexports.checkObjectTag = checkObjectTag;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkValid = void 0;\nfunction checkValid(_value, _rules) {\n    _rules.forEach((rule) => {\n        if (rule.validator) {\n            rule.validator(_value);\n        }\n        else if (rule.pattern && !rule.pattern.test(_value)) {\n            throw new Error(rule.msg);\n        }\n    });\n}\nexports.checkValid = checkValid;\n","const proto = exports;\n/**\n * deleteObjectTagging\n * @param {String} name - object name\n * @param {Object} options\n */\n\nproto.deleteObjectTagging = async function deleteObjectTagging(\n  name,\n  options = {}\n) {\n  options.subres = Object.assign({ tagging: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  name = this._objectName(name);\n  const params = this._objectRequestParams('DELETE', name, options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","/* eslint-disable no-use-before-define */\nconst proto = exports;\nconst { isObject } = require('../utils/isObject');\nconst { isArray } = require('../utils/isArray');\n\n\nproto.getBucketVersions = getBucketVersions;\nproto.listObjectVersions = getBucketVersions;\n\nasync function getBucketVersions(query = {}, options = {}) {\n  // prefix, key-marker, max-keys, delimiter, encoding-type, version-id-marker\n  if (query.versionIdMarker && query.keyMarker === undefined) {\n    throw new Error('A version-id marker cannot be specified without a key marker');\n  }\n\n  options.subres = Object.assign({ versions: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('GET', '', options);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  params.query = formatQuery(query);\n\n  const result = await this.request(params);\n  let objects = result.data.Version || [];\n  let deleteMarker = result.data.DeleteMarker || [];\n  const that = this;\n  if (objects) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n    objects = objects.map(obj => ({\n      name: obj.Key,\n      url: that._objectUrl(obj.Key),\n      lastModified: obj.LastModified,\n      isLatest: obj.IsLatest === 'true',\n      versionId: obj.VersionId,\n      etag: obj.ETag,\n      type: obj.Type,\n      size: Number(obj.Size),\n      storageClass: obj.StorageClass,\n      owner: {\n        id: obj.Owner.ID,\n        displayName: obj.Owner.DisplayName\n      }\n    }));\n  }\n  if (deleteMarker) {\n    if (!isArray(deleteMarker)) {\n      deleteMarker = [deleteMarker];\n    }\n    deleteMarker = deleteMarker.map(obj => ({\n      name: obj.Key,\n      lastModified: obj.LastModified,\n      versionId: obj.VersionId,\n      owner: {\n        id: obj.Owner.ID,\n        displayName: obj.Owner.DisplayName\n      }\n    }));\n  }\n  let prefixes = result.data.CommonPrefixes || null;\n  if (prefixes) {\n    if (!isArray(prefixes)) {\n      prefixes = [prefixes];\n    }\n    prefixes = prefixes.map(item => item.Prefix);\n  }\n  return {\n    res: result.res,\n    objects,\n    deleteMarker,\n    prefixes,\n    // attirbute of legacy error\n    nextMarker: result.data.NextKeyMarker || null,\n    // attirbute of legacy error\n    NextVersionIdMarker: result.data.NextVersionIdMarker || null,\n    nextKeyMarker: result.data.NextKeyMarker || null,\n    nextVersionIdMarker: result.data.NextVersionIdMarker || null,\n    isTruncated: result.data.IsTruncated === 'true'\n  };\n}\n\n\nfunction camel2Line(name) {\n  return name.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n\nfunction formatQuery(query = {}) {\n  const obj = {};\n  if (isObject(query)) {\n    Object.keys(query).forEach((key) => {\n      obj[camel2Line(key)] = query[key];\n    });\n  }\n\n  return obj;\n}\n\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isArray = void 0;\nexports.isArray = (obj) => {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","/* eslint-disable object-curly-newline */\nconst utility = require('utility');\nconst { obj2xml } = require('../utils/obj2xml');\n\nconst proto = exports;\n\nproto.deleteMulti = async function deleteMulti(names, options = {}) {\n  const objects = [];\n  if (!names || !names.length) {\n    throw new Error('names is required');\n  }\n  for (let i = 0; i < names.length; i++) {\n    const object = {};\n    if (typeof names[i] === 'string') {\n      object.Key = utility.escape(this._objectName(names[i]));\n    } else {\n      const { key, versionId } = names[i];\n      object.Key = utility.escape(this._objectName(key));\n      object.VersionId = versionId;\n    }\n    objects.push(object);\n  }\n\n  const paramXMLObj = {\n    Delete: {\n      Quiet: !!options.quiet,\n      Object: objects\n    }\n  };\n\n  const paramXML = obj2xml(paramXMLObj, {\n    headers: true\n  });\n\n  options.subres = Object.assign({ delete: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('POST', '', options);\n  params.mime = 'xml';\n  params.content = paramXML;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n  const result = await this.request(params);\n\n  const r = result.data;\n  let deleted = (r && r.Deleted) || null;\n  if (deleted) {\n    if (!Array.isArray(deleted)) {\n      deleted = [deleted];\n    }\n  }\n  return {\n    res: result.res,\n    deleted: deleted || []\n  };\n};\n","const proto = exports;\n\n/*\n * Get object's ACL\n * @param {String} name the object key\n * @param {Object} options\n * @return {Object}\n */\nproto.getACL = async function getACL(name, options = {}) {\n  options.subres = Object.assign({ acl: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  name = this._objectName(name);\n\n  const params = this._objectRequestParams('GET', name, options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n\n  const result = await this.request(params);\n\n  return {\n    acl: result.data.AccessControlList.Grant,\n    owner: {\n      id: result.data.Owner.ID,\n      displayName: result.data.Owner.DisplayName\n    },\n    res: result.res\n  };\n};\n","const proto = exports;\n\n/*\n * Set object's ACL\n * @param {String} name the object key\n * @param {String} acl the object ACL\n * @param {Object} options\n */\nproto.putACL = async function putACL(name, acl, options) {\n  options = options || {};\n  options.subres = Object.assign({ acl: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  options.headers = options.headers || {};\n  options.headers['x-oss-object-acl'] = acl;\n  name = this._objectName(name);\n\n  const params = this._objectRequestParams('PUT', name, options);\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n","const proto = exports;\n/**\n * head\n * @param {String} name - object name\n * @param {Object} options\n * @param {{res}}\n */\n\nproto.head = async function head(name, options = {}) {\n  options.subres = Object.assign({}, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('HEAD', name, options);\n  params.successStatuses = [200, 304];\n\n  const result = await this.request(params);\n\n  const data = {\n    meta: null,\n    res: result.res,\n    status: result.status\n  };\n\n  if (result.status === 200) {\n    Object.keys(result.headers).forEach((k) => {\n      if (k.indexOf('x-oss-meta-') === 0) {\n        if (!data.meta) {\n          data.meta = {};\n        }\n        data.meta[k.substring(11)] = result.headers[k];\n      }\n    });\n  }\n  return data;\n};\n","const proto = exports;\n/**\n * delete\n * @param {String} name - object name\n * @param {Object} options\n * @param {{res}}\n */\n\nproto.delete = async function _delete(name, options = {}) {\n  options.subres = Object.assign({}, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('DELETE', name, options);\n  params.successStatuses = [204];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n","const fs = require('fs');\nconst is = require('is-type-of');\n\nconst proto = exports;\n/**\n * get\n * @param {String} name - object name\n * @param {String | Stream} file\n * @param {Object} options\n * @param {{res}}\n */\nproto.get = async function get(name, file, options = {}) {\n  let writeStream = null;\n  let needDestroy = false;\n\n  if (is.writableStream(file)) {\n    writeStream = file;\n  } else if (is.string(file)) {\n    writeStream = fs.createWriteStream(file);\n    needDestroy = true;\n  } else {\n    // get(name, options)\n    options = file;\n  }\n\n  options = options || {};\n  const isBrowserEnv = process && process.browser;\n  const responseCacheControl = options.responseCacheControl === null ? '' : 'no-cache';\n  const defaultSubresOptions =\n    isBrowserEnv && responseCacheControl ? { 'response-cache-control': responseCacheControl } : {};\n  options.subres = Object.assign(defaultSubresOptions, options.subres);\n\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  if (options.process) {\n    options.subres['x-oss-process'] = options.process;\n  }\n\n  let result;\n  try {\n    const params = this._objectRequestParams('GET', name, options);\n    params.writeStream = writeStream;\n    params.successStatuses = [200, 206, 304];\n\n    result = await this.request(params);\n\n    if (needDestroy) {\n      writeStream.destroy();\n    }\n  } catch (err) {\n    if (needDestroy) {\n      writeStream.destroy();\n      // should delete the exists file before throw error\n      await this._deleteFileSafe(file);\n    }\n    throw err;\n  }\n\n  return {\n    res: result.res,\n    content: result.data\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.postAsyncFetch = void 0;\nconst obj2xml_1 = require(\"../utils/obj2xml\");\n/*\n * postAsyncFetch\n * @param {String} name the object key\n * @param {String} url\n * @param {Object} options\n *        {String} options.host\n *        {String} options.contentMD5\n *        {String} options.callback\n *        {String} options.storageClass Standard/IA/Archive\n *        {Boolean} options.ignoreSameKey  default value true\n */\nasync function postAsyncFetch(object, url, options = {}) {\n    options.subres = Object.assign({ asyncFetch: '' }, options.subres);\n    options.headers = options.headers || {};\n    object = this._objectName(object);\n    const { host = '', contentMD5 = '', callback = '', storageClass = '', ignoreSameKey = true } = options;\n    const paramXMLObj = {\n        AsyncFetchTaskConfiguration: {\n            Url: url,\n            Object: object,\n            Host: host,\n            ContentMD5: contentMD5,\n            Callback: callback,\n            StorageClass: storageClass,\n            IgnoreSameKey: ignoreSameKey\n        }\n    };\n    const params = this._objectRequestParams('POST', '', options);\n    params.mime = 'xml';\n    params.xmlResponse = true;\n    params.successStatuses = [200];\n    params.content = obj2xml_1.obj2xml(paramXMLObj);\n    const result = await this.request(params);\n    return {\n        res: result.res,\n        status: result.status,\n        taskId: result.data.TaskId\n    };\n}\nexports.postAsyncFetch = postAsyncFetch;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAsyncFetch = void 0;\nconst formatObjKey_1 = require(\"../utils/formatObjKey\");\n/*\n * getAsyncFetch\n * @param {String} asyncFetch taskId\n * @param {Object} options\n */\nasync function getAsyncFetch(taskId, options = {}) {\n    options.subres = Object.assign({ asyncFetch: '' }, options.subres);\n    options.headers = options.headers || {};\n    const params = this._objectRequestParams('GET', '', options);\n    params.headers['x-oss-task-id'] = taskId;\n    params.successStatuses = [200];\n    params.xmlResponse = true;\n    const result = await this.request(params);\n    const taskInfo = formatObjKey_1.formatObjKey(result.data.TaskInfo, 'firstLowerCase');\n    return {\n        res: result.res,\n        status: result.status,\n        state: result.data.State,\n        taskInfo\n    };\n}\nexports.getAsyncFetch = getAsyncFetch;\n","const urlutil = require('url');\nconst { isIP } = require('../utils/isIP');\n\nconst proto = exports;\n\n/**\n * Get Object url by name\n * @param {String} name - object name\n * @param {String} [baseUrl] - If provide `baseUrl`, will use `baseUrl` instead the default `endpoint and bucket`.\n * @return {String} object url include bucket\n */\nproto.generateObjectUrl = function generateObjectUrl(name, baseUrl) {\n  if (isIP(this.options.endpoint.hostname)) {\n    throw new Error('can not get the object URL when endpoint is IP');\n  }\n  if (!baseUrl) {\n    baseUrl = this.options.endpoint.format();\n    const copyUrl = urlutil.parse(baseUrl);\n    const { bucket } = this.options;\n\n    copyUrl.hostname = `${bucket}.${copyUrl.hostname}`;\n    copyUrl.host = `${bucket}.${copyUrl.host}`;\n    baseUrl = copyUrl.format();\n  } else if (baseUrl[baseUrl.length - 1] !== '/') {\n    baseUrl += '/';\n  }\n  return baseUrl + this._escape(this._objectName(name));\n};\n","const { isIP } = require('../utils/isIP');\n\nconst proto = exports;\n/**\n * Get Object url by name\n * @param {String} name - object name\n * @param {String} [baseUrl] - If provide `baseUrl`,\n *        will use `baseUrl` instead the default `endpoint`.\n * @return {String} object url\n */\nproto.getObjectUrl = function getObjectUrl(name, baseUrl) {\n  if (isIP(this.options.endpoint.hostname)) {\n    throw new Error('can not get the object URL when endpoint is IP');\n  }\n  if (!baseUrl) {\n    baseUrl = this.options.endpoint.format();\n  } else if (baseUrl[baseUrl.length - 1] !== '/') {\n    baseUrl += '/';\n  }\n  return baseUrl + this._escape(this._objectName(name));\n};\n","const urlutil = require('url');\nconst utility = require('utility');\nconst copy = require('copy-to');\nconst signHelper = require('../../common/signUtils');\nconst { isIP } = require('../utils/isIP');\n\nconst proto = exports;\n\nproto.signatureUrl = function signatureUrl(name, options) {\n  if (isIP(this.options.endpoint.hostname)) {\n    throw new Error('can not get the object URL when endpoint is IP');\n  }\n  options = options || {};\n  name = this._objectName(name);\n  options.method = options.method || 'GET';\n  const expires = utility.timestamp() + (options.expires || 1800);\n  const params = {\n    bucket: this.options.bucket,\n    object: name\n  };\n\n  const resource = this._getResource(params);\n\n  if (this.options.stsToken) {\n    options['security-token'] = this.options.stsToken;\n  }\n\n  const signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);\n\n  const url = urlutil.parse(this._getReqUrl(params));\n  url.query = {\n    OSSAccessKeyId: this.options.accessKeyId,\n    Expires: expires,\n    Signature: signRes.Signature\n  };\n\n  copy(signRes.subResource).to(url.query);\n\n  return url.format();\n};\n","const debug = require('debug')('ali-oss:object');\nconst fs = require('fs');\nconst is = require('is-type-of');\nconst copy = require('copy-to');\nconst path = require('path');\nconst mime = require('mime');\nconst callback = require('./common/callback');\nconst { Transform } = require('stream');\nconst pump = require('pump');\nconst { isBuffer } = require('./common/utils/isBuffer');\n\nconst proto = exports;\n\n/**\n * Object operations\n */\n\n/**\n * append an object from String(file path)/Buffer/ReadableStream\n * @param {String} name the object key\n * @param {Mixed} file String(file path)/Buffer/ReadableStream\n * @param {Object} options\n * @return {Object}\n */\nproto.append = async function append(name, file, options) {\n  options = options || {};\n  if (options.position === undefined) options.position = '0';\n  options.subres = {\n    append: '',\n    position: options.position\n  };\n  options.method = 'POST';\n\n  const result = await this.put(name, file, options);\n  result.nextAppendPosition = result.res.headers['x-oss-next-append-position'];\n  return result;\n};\n\n/**\n * put an object from String(file path)/Buffer/ReadableStream\n * @param {String} name the object key\n * @param {Mixed} file String(file path)/Buffer/ReadableStream\n * @param {Object} options\n *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64\n *        {String} options.callback.url  the OSS sends a callback request to this URL\n *        {String} options.callback.host  The host header value for initiating callback requests\n *        {String} options.callback.body  The value of the request body when a callback is initiated\n *        {String} options.callback.contentType  The Content-Type of the callback requests initiatiated\n *        {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:\n *                  customValue = {\n *                    key1: 'value1',\n *                    key2: 'value2'\n *                  }\n * @return {Object}\n */\nproto.put = async function put(name, file, options) {\n  let content;\n  options = options || {};\n  name = this._objectName(name);\n\n  if (isBuffer(file)) {\n    content = file;\n  } else if (is.string(file)) {\n    const stats = fs.statSync(file);\n    if (!stats.isFile()) {\n      throw new Error(`${file} is not file`);\n    }\n    options.mime = options.mime || mime.getType(path.extname(file));\n    const stream = fs.createReadStream(file);\n    options.contentLength = await this._getFileSize(file);\n    return await this.putStream(name, stream, options);\n  } else if (is.readableStream(file)) {\n    return await this.putStream(name, file, options);\n  } else {\n    throw new TypeError('Must provide String/Buffer/ReadableStream for put.');\n  }\n\n  options.headers = options.headers || {};\n  this._convertMetaToHeaders(options.meta, options.headers);\n\n  const method = options.method || 'PUT';\n  const params = this._objectRequestParams(method, name, options);\n\n  callback.encodeCallback(params, options);\n\n  params.mime = options.mime;\n  params.content = content;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  const ret = {\n    name,\n    url: this._objectUrl(name),\n    res: result.res\n  };\n\n  if (params.headers && params.headers['x-oss-callback']) {\n    ret.data = JSON.parse(result.data.toString());\n  }\n\n  return ret;\n};\n\n/**\n * put an object from ReadableStream. If `options.contentLength` is\n * not provided, chunked encoding is used.\n * @param {String} name the object key\n * @param {Readable} stream the ReadableStream\n * @param {Object} options\n * @return {Object}\n */\nproto.putStream = async function putStream(name, stream, options) {\n  options = options || {};\n  options.headers = options.headers || {};\n  name = this._objectName(name);\n  if (options.contentLength) {\n    options.headers['Content-Length'] = options.contentLength;\n  } else {\n    options.headers['Transfer-Encoding'] = 'chunked';\n  }\n  this._convertMetaToHeaders(options.meta, options.headers);\n\n  const method = options.method || 'PUT';\n  const params = this._objectRequestParams(method, name, options);\n  callback.encodeCallback(params, options);\n  params.mime = options.mime;\n  const transform = new Transform();\n  // must remove http stream header for signature\n  transform._transform = function _transform(chunk, encoding, done) {\n    this.push(chunk);\n    done();\n  };\n  params.stream = pump(stream, transform);\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  const ret = {\n    name,\n    url: this._objectUrl(name),\n    res: result.res\n  };\n\n  if (params.headers && params.headers['x-oss-callback']) {\n    ret.data = JSON.parse(result.data.toString());\n  }\n\n  return ret;\n};\n\nproto.getStream = async function getStream(name, options) {\n  options = options || {};\n\n  if (options.process) {\n    options.subres = options.subres || {};\n    options.subres['x-oss-process'] = options.process;\n  }\n\n  const params = this._objectRequestParams('GET', name, options);\n  params.customResponse = true;\n  params.successStatuses = [200, 206, 304];\n\n  const result = await this.request(params);\n\n  return {\n    stream: result.res,\n    res: {\n      status: result.status,\n      headers: result.headers\n    }\n  };\n};\n\nproto.putMeta = async function putMeta(name, meta, options) {\n  return await this.copy(name, name, {\n    meta: meta || {},\n    timeout: options && options.timeout,\n    ctx: options && options.ctx\n  });\n};\n\nproto.list = async function list(query, options) {\n  // prefix, marker, max-keys, delimiter\n\n  const params = this._objectRequestParams('GET', '', options);\n  params.query = query;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n  let objects = result.data.Contents;\n  const that = this;\n  if (objects) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n    objects = objects.map(obj => ({\n      name: obj.Key,\n      url: that._objectUrl(obj.Key),\n      lastModified: obj.LastModified,\n      etag: obj.ETag,\n      type: obj.Type,\n      size: Number(obj.Size),\n      storageClass: obj.StorageClass,\n      owner: {\n        id: obj.Owner.ID,\n        displayName: obj.Owner.DisplayName\n      }\n    }));\n  }\n  let prefixes = result.data.CommonPrefixes || null;\n  if (prefixes) {\n    if (!Array.isArray(prefixes)) {\n      prefixes = [prefixes];\n    }\n    prefixes = prefixes.map(item => item.Prefix);\n  }\n  return {\n    res: result.res,\n    objects,\n    prefixes,\n    nextMarker: result.data.NextMarker || null,\n    isTruncated: result.data.IsTruncated === 'true'\n  };\n};\n\nproto.listV2 = async function listV2(query, options = {}) {\n  const continuation_token = query['continuation-token'] || query.continuationToken;\n  delete query['continuation-token'];\n  delete query.continuationToken;\n  if (continuation_token) {\n    options.subres = Object.assign(\n      {\n        'continuation-token': continuation_token\n      },\n      options.subres\n    );\n  }\n  const params = this._objectRequestParams('GET', '', options);\n  params.query = Object.assign({ 'list-type': 2 }, query);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n  let objects = result.data.Contents;\n  const that = this;\n  if (objects) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n    objects = objects.map(obj => ({\n      name: obj.Key,\n      url: that._objectUrl(obj.Key),\n      lastModified: obj.LastModified,\n      etag: obj.ETag,\n      type: obj.Type,\n      size: Number(obj.Size),\n      storageClass: obj.StorageClass,\n      owner: obj.Owner\n        ? {\n            id: obj.Owner.ID,\n            displayName: obj.Owner.DisplayName\n          }\n        : null\n    }));\n  }\n  let prefixes = result.data.CommonPrefixes || null;\n  if (prefixes) {\n    if (!Array.isArray(prefixes)) {\n      prefixes = [prefixes];\n    }\n    prefixes = prefixes.map(item => item.Prefix);\n  }\n  return {\n    res: result.res,\n    objects,\n    prefixes,\n    isTruncated: result.data.IsTruncated === 'true',\n    keyCount: +result.data.KeyCount,\n    continuationToken: result.data.ContinuationToken || null,\n    nextContinuationToken: result.data.NextContinuationToken || null\n  };\n};\n\n/**\n * Restore Object\n * @param {String} name the object key\n * @param {Object} options\n * @returns {{res}}\n */\nproto.restore = async function restore(name, options) {\n  options = options || {};\n  options.subres = Object.assign({ restore: '' }, options.subres);\n  if (options.versionId) {\n    options.subres.versionId = options.versionId;\n  }\n  const params = this._objectRequestParams('POST', name, options);\n  params.successStatuses = [202];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n\nproto._objectUrl = function _objectUrl(name) {\n  return this._getReqUrl({ bucket: this.options.bucket, object: name });\n};\n\n/**\n * generator request params\n * @return {Object} params\n *\n * @api private\n */\n\nproto._objectRequestParams = function (method, name, options) {\n  if (!this.options.bucket && !this.options.cname) {\n    throw new Error('Please create a bucket first');\n  }\n\n  options = options || {};\n  name = this._objectName(name);\n  const params = {\n    object: name,\n    bucket: this.options.bucket,\n    method,\n    subres: options && options.subres,\n    timeout: options && options.timeout,\n    ctx: options && options.ctx\n  };\n\n  if (options.headers) {\n    params.headers = {};\n    copy(options.headers).to(params.headers);\n  }\n  return params;\n};\n\nproto._objectName = function (name) {\n  return name.replace(/^\\/+/, '');\n};\n\nproto._statFile = function (filepath) {\n  return new Promise((resolve, reject) => {\n    fs.stat(filepath, (err, stats) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n};\n\nproto._convertMetaToHeaders = function (meta, headers) {\n  if (!meta) {\n    return;\n  }\n\n  Object.keys(meta).forEach(k => {\n    headers[`x-oss-meta-${k}`] = meta[k];\n  });\n};\n\nproto._deleteFileSafe = function (filepath) {\n  return new Promise(resolve => {\n    fs.exists(filepath, exists => {\n      if (!exists) {\n        resolve();\n      } else {\n        fs.unlink(filepath, err => {\n          if (err) {\n            debug('unlink %j error: %s', filepath, err);\n          }\n          resolve();\n        });\n      }\n    });\n  });\n};\n","\n\nexports.encodeCallback = function encodeCallback(reqParams, options) {\n  reqParams.headers = reqParams.headers || {};\n  if (!Object.prototype.hasOwnProperty.call(reqParams.headers, 'x-oss-callback')) {\n    if (options.callback) {\n      const json = {\n        callbackUrl: encodeURI(options.callback.url),\n        callbackBody: options.callback.body\n      };\n      if (options.callback.host) {\n        json.callbackHost = options.callback.host;\n      }\n      if (options.callback.contentType) {\n        json.callbackBodyType = options.callback.contentType;\n      }\n      const callback = Buffer.from(JSON.stringify(json)).toString('base64');\n      reqParams.headers['x-oss-callback'] = callback;\n\n      if (options.callback.customValue) {\n        const callbackVar = {};\n        Object.keys(options.callback.customValue).forEach((key) => {\n          callbackVar[`x:${key}`] = options.callback.customValue[key];\n        });\n        reqParams.headers['x-oss-callback-var'] = Buffer.from(JSON.stringify(callbackVar)).toString('base64');\n      }\n    }\n  }\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBuffer = void 0;\nfunction isBuffer(obj) {\n    return Buffer.isBuffer(obj);\n}\nexports.isBuffer = isBuffer;\n","const merge = require('merge-descriptors');\n\nconst proto = exports;\n\nmerge(proto, require('./processObjectSave'));\n","/* eslint-disable no-use-before-define */\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst querystring = require('querystring');\nconst { Base64: { encode: str2Base64 } } = require('js-base64');\n\nconst proto = exports;\n\nproto.processObjectSave = async function processObjectSave(sourceObject, targetObject, process, targetBucket) {\n  checkArgs(sourceObject, 'sourceObject');\n  checkArgs(targetObject, 'targetObject');\n  checkArgs(process, 'process');\n  targetObject = this._objectName(targetObject);\n  if (targetBucket) {\n    _checkBucketName(targetBucket);\n  }\n\n  const params = this._objectRequestParams('POST', sourceObject, {\n    subres: 'x-oss-process'\n  });\n\n  const bucketParam = targetBucket ? `,b_${str2Base64(targetBucket)}` : '';\n  targetObject = str2Base64(targetObject);\n\n  const content = {\n    'x-oss-process': `${process}|sys/saveas,o_${targetObject}${bucketParam}`\n  };\n  params.content = querystring.stringify(content);\n\n  const result = await this.request(params);\n  return {\n    res: result.res,\n    status: result.res.status\n  };\n};\n\nfunction checkArgs(name, key) {\n  if (!name) {\n    throw new Error(`${key} is required`);\n  }\n  if (typeof name !== 'string') {\n    throw new Error(`${key} must be String`);\n  }\n}\n","const merge = require('merge-descriptors');\n\nconst proto = exports;\n\nmerge(proto, require('./getBucketRequestPayment'));\nmerge(proto, require('./putBucketRequestPayment'));\nmerge(proto, require('./putBucketEncryption'));\nmerge(proto, require('./getBucketEncryption'));\nmerge(proto, require('./deleteBucketEncryption'));\nmerge(proto, require('./getBucketTags'));\nmerge(proto, require('./putBucketTags'));\nmerge(proto, require('./deleteBucketTags'));\nmerge(proto, require('./putBucket'));\nmerge(proto, require('./getBucketWebsite'));\nmerge(proto, require('./putBucketWebsite'));\nmerge(proto, require('./deleteBucketWebsite'));\nmerge(proto, require('./getBucketLifecycle'));\nmerge(proto, require('./putBucketLifecycle'));\nmerge(proto, require('./deleteBucketLifecycle'));\nmerge(proto, require('./getBucketPolicy'));\nmerge(proto, require('./putBucketPolicy'));\nmerge(proto, require('./deleteBucketPolicy'));\nmerge(proto, require('./getBucketVersioning'));\nmerge(proto, require('./putBucketVersioning'));\nmerge(proto, require('./getBucketInventory'));\nmerge(proto, require('./deleteBucketInventory'));\nmerge(proto, require('./listBucketInventory'));\nmerge(proto, require('./putBucketInventory'));\nmerge(proto, require('./abortBucketWorm'));\nmerge(proto, require('./completeBucketWorm'));\nmerge(proto, require('./extendBucketWorm'));\nmerge(proto, require('./getBucketWorm'));\nmerge(proto, require('./initiateBucketWorm'));\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * getBucketRequestPayment\n * @param {String} bucketName - bucket name\n * @param {Object} options\n */\n\nproto.getBucketRequestPayment = async function getBucketRequestPayment(bucketName, options) {\n  options = options || {};\n\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams('GET', bucketName, 'requestPayment', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n\n  const result = await this.request(params);\n\n  return {\n    status: result.status,\n    res: result.res,\n    payer: result.data.Payer\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\n\nconst proto = exports;\n/**\n * putBucketRequestPayment\n * @param {String} bucketName\n * @param {String} payer\n * @param {Object} options\n */\nconst payerAll = ['BucketOwner', 'Requester'];\n\nproto.putBucketRequestPayment = async function putBucketRequestPayment(\n  bucketName,\n  payer,\n  options\n) {\n  options = options || {};\n  if (!payer || payerAll.indexOf(payer) < 0) {\n    throw new Error('payer must be BucketOwner or Requester');\n  }\n\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams(\n    'PUT',\n    bucketName,\n    'requestPayment',\n    options\n  );\n  params.successStatuses = [200];\n\n  const paramXMLObj = {\n    RequestPaymentConfiguration: {\n      Payer: payer\n    }\n  };\n  const paramXML = obj2xml(paramXMLObj, {\n    headers: true\n  });\n\n  params.mime = 'xml';\n  params.content = paramXML;\n\n  const result = await this.request(params);\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const proto = exports;\n// const jstoxml = require('jstoxml');\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\n/**\n * putBucketEncryption\n * @param {String} bucketName - bucket name\n * @param {Object} options\n */\n\nproto.putBucketEncryption = async function putBucketEncryption(bucketName, options) {\n  options = options || {};\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams('PUT', bucketName, 'encryption', options);\n  params.successStatuses = [200];\n  const paramXMLObj = {\n    ServerSideEncryptionRule: {\n      ApplyServerSideEncryptionByDefault: {\n        SSEAlgorithm: options.SSEAlgorithm\n      }\n    }\n  };\n  if (options.KMSMasterKeyID !== undefined) {\n    paramXMLObj.ServerSideEncryptionRule.ApplyServerSideEncryptionByDefault.KMSMasterKeyID = options.KMSMasterKeyID;\n  }\n  const paramXML = obj2xml(paramXMLObj, {\n    headers: true\n  });\n  params.mime = 'xml';\n  params.content = paramXML;\n  const result = await this.request(params);\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * getBucketEncryption\n * @param {String} bucketName - bucket name\n */\n\nproto.getBucketEncryption = async function getBucketEncryption(bucketName) {\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams('GET', bucketName, 'encryption');\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  const encryption = result.data.ApplyServerSideEncryptionByDefault;\n  return {\n    encryption,\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n// const jstoxml = require('jstoxml');\n/**\n * deleteBucketEncryption\n * @param {String} bucketName - bucket name\n */\n\nproto.deleteBucketEncryption = async function deleteBucketEncryption(bucketName) {\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams('DELETE', bucketName, 'encryption');\n  params.successStatuses = [204];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const proto = exports;\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { formatTag } = require('../utils/formatTag');\n/**\n * getBucketTags\n * @param {String} name - bucket name\n * @param {Object} options\n * @return {Object}\n */\n\nproto.getBucketTags = async function getBucketTags(name, options = {}) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'tagging', options);\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  const Tagging = await this.parseXML(result.data);\n\n\n  return {\n    status: result.status,\n    res: result.res,\n    tag: formatTag(Tagging)\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatTag = void 0;\nconst isObject_1 = require(\"./isObject\");\nfunction formatTag(obj) {\n    if (obj.Tagging !== undefined) {\n        obj = obj.Tagging.TagSet.Tag;\n    }\n    else if (obj.TagSet !== undefined) {\n        obj = obj.TagSet.Tag;\n    }\n    else if (obj.Tag !== undefined) {\n        obj = obj.Tag;\n    }\n    obj = obj && isObject_1.isObject(obj) ? [obj] : obj || [];\n    const tag = {};\n    obj.forEach((item) => {\n        tag[item.Key] = item.Value;\n    });\n    return tag;\n}\nexports.formatTag = formatTag;\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\nconst { checkBucketTag } = require('../utils/checkBucketTag');\n\nconst proto = exports;\n/**\n * putBucketTags\n * @param {String} name - bucket name\n * @param {Object} tag -  bucket tag, eg: `{a: \"1\", b: \"2\"}`\n * @param {Object} options\n */\n\nproto.putBucketTags = async function putBucketTags(name, tag, options = {}) {\n  _checkBucketName(name);\n  checkBucketTag(tag);\n  const params = this._bucketRequestParams('PUT', name, 'tagging', options);\n  params.successStatuses = [200];\n  tag = Object.keys(tag).map(key => ({\n    Key: key,\n    Value: tag[key]\n  }));\n\n  const paramXMLObj = {\n    Tagging: {\n      TagSet: {\n        Tag: tag\n      }\n    }\n  };\n\n  params.mime = 'xml';\n  params.content = obj2xml(paramXMLObj);\n\n  const result = await this.request(params);\n  return {\n    res: result.res,\n    status: result.status\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBucketTag = void 0;\nconst { checkValid } = require('./checkValid');\nconst { isObject } = require('./isObject');\nconst commonRules = [\n    {\n        validator: (value) => {\n            if (typeof value !== 'string') {\n                throw new Error('the key and value of the tag must be String');\n            }\n        }\n    }\n];\nconst rules = {\n    key: [\n        ...commonRules,\n        {\n            pattern: /^.{1,64}$/,\n            msg: 'tag key can be a maximum of 64 bytes in length'\n        },\n        {\n            pattern: /^(?!https*:\\/\\/|Aliyun)/,\n            msg: 'tag key can not startsWith: http://, https://, Aliyun'\n        }\n    ],\n    value: [\n        ...commonRules,\n        {\n            pattern: /^.{0,128}$/,\n            msg: 'tag value can be a maximum of 128 bytes in length'\n        }\n    ]\n};\nexports.checkBucketTag = (tag) => {\n    if (!isObject(tag)) {\n        throw new Error('bucket tag must be Object');\n    }\n    const entries = Object.entries(tag);\n    if (entries.length > 20) {\n        throw new Error('maximum of 20 tags for a bucket');\n    }\n    const rulesIndexKey = ['key', 'value'];\n    entries.forEach((keyValue) => {\n        keyValue.forEach((item, index) => {\n            checkValid(item, rules[rulesIndexKey[index]]);\n        });\n    });\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * deleteBucketTags\n * @param {String} name - bucket name\n * @param {Object} options\n */\n\nproto.deleteBucketTags = async function deleteBucketTags(name, options = {}) {\n  _checkBucketName(name);\n\n  const params = this._bucketRequestParams('DELETE', name, 'tagging', options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const proto = exports;\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\n\nproto.putBucket = async function putBucket(name, options = {}) {\n  _checkBucketName(name, true);\n  const params = this._bucketRequestParams('PUT', name, '', options);\n\n  const CreateBucketConfiguration = {};\n  const paramlXMLObJ = {\n    CreateBucketConfiguration\n  };\n\n  const storageClass = options.StorageClass || options.storageClass;\n  const dataRedundancyType = options.DataRedundancyType || options.dataRedundancyType;\n  if (storageClass || dataRedundancyType) {\n    storageClass && (CreateBucketConfiguration.StorageClass = storageClass);\n    dataRedundancyType && (CreateBucketConfiguration.DataRedundancyType = dataRedundancyType);\n    params.mime = 'xml';\n    params.content = obj2xml(paramlXMLObJ, { headers: true });\n  }\n  const { acl, headers = {} } = options;\n  acl && (headers['x-oss-acl'] = acl);\n  params.headers = headers;\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    bucket: (result.headers.location && result.headers.location.substring(1)) || null,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { isObject } = require('../utils/isObject');\n\nconst proto = exports;\n\nproto.getBucketWebsite = async function getBucketWebsite(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'website', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  let routingRules = [];\n  if (result.data.RoutingRules && result.data.RoutingRules.RoutingRule) {\n    if (isObject(result.data.RoutingRules.RoutingRule)) {\n      routingRules = [result.data.RoutingRules.RoutingRule];\n    } else {\n      routingRules = result.data.RoutingRules.RoutingRule;\n    }\n  }\n  return {\n    index: (result.data.IndexDocument && result.data.IndexDocument.Suffix) || '',\n    supportSubDir: (result.data.IndexDocument && result.data.IndexDocument.SupportSubDir) || 'false',\n    type: (result.data.IndexDocument && result.data.IndexDocument.Type),\n    routingRules,\n    error: (result.data.ErrorDocument && result.data.ErrorDocument.Key) || null,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\nconst { isArray } = require('../utils/isArray');\n\nconst proto = exports;\nproto.putBucketWebsite = async function putBucketWebsite(name, config = {}, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('PUT', name, 'website', options);\n  const IndexDocument = {\n    Suffix: config.index || 'index.html'\n  };\n  const WebsiteConfiguration = {\n    IndexDocument\n  };\n  let website = {\n    WebsiteConfiguration\n  };\n\n  if (config.supportSubDir) {\n    IndexDocument.SupportSubDir = config.supportSubDir;\n  }\n\n  if (config.type) {\n    IndexDocument.Type = config.type;\n  }\n\n  if (config.error) {\n    WebsiteConfiguration.ErrorDocument = {\n      Key: config.error\n    };\n  }\n\n  if (config.routingRules !== undefined) {\n    if (!isArray(config.routingRules)) {\n      throw new Error('RoutingRules must be Array');\n    }\n    WebsiteConfiguration.RoutingRules = {\n      RoutingRule: config.routingRules\n    };\n  }\n\n  website = obj2xml(website);\n  params.content = website;\n  params.mime = 'xml';\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n\nproto.deleteBucketWebsite = async function deleteBucketWebsite(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('DELETE', name, 'website', options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { isArray } = require('../utils/isArray');\nconst { formatObjKey } = require('../utils/formatObjKey');\n\nconst proto = exports;\n\nproto.getBucketLifecycle = async function getBucketLifecycle(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'lifecycle', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  let rules = result.data.Rule || null;\n  if (rules) {\n    if (!isArray(rules)) {\n      rules = [rules];\n    }\n    rules = rules.map((_) => {\n      if (_.ID) {\n        _.id = _.ID;\n        delete _.ID;\n      }\n      if (_.Tag && !isArray(_.Tag)) {\n        _.Tag = [_.Tag];\n      }\n      return formatObjKey(_, 'firstLowerCase');\n    });\n  }\n  return {\n    rules,\n    res: result.res\n  };\n};\n\n","/* eslint-disable no-use-before-define */\nconst { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { isArray } = require('../utils/isArray');\nconst { deepCopy } = require('../utils/deepCopy');\nconst { isObject } = require('../utils/isObject');\nconst { obj2xml } = require('../utils/obj2xml');\nconst { checkObjectTag } = require('../utils/checkObjectTag');\nconst { getStrBytesCount } = require('../utils/getStrBytesCount');\n\nconst proto = exports;\n\n\nproto.putBucketLifecycle = async function putBucketLifecycle(name, rules, options) {\n  _checkBucketName(name);\n\n  if (!isArray(rules)) {\n    throw new Error('rules must be Array');\n  }\n\n  const params = this._bucketRequestParams('PUT', name, 'lifecycle', options);\n  const Rule = [];\n  const paramXMLObj = {\n    LifecycleConfiguration: {\n      Rule\n    }\n  };\n\n  rules.forEach((_) => {\n    defaultDaysAndDate2Expiration(_); // todo delete, 兼容旧版本\n    checkRule(_);\n    if (_.id) {\n      _.ID = _.id;\n      delete _.id;\n    }\n    Rule.push(_);\n  });\n\n  const paramXML = obj2xml(paramXMLObj, {\n    headers: true,\n    firstUpperCase: true\n  });\n\n  params.content = paramXML;\n  params.mime = 'xml';\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\n// todo delete, 兼容旧版本\nfunction defaultDaysAndDate2Expiration(obj) {\n  if (obj.days) {\n    obj.expiration = {\n      days: obj.days\n    };\n  }\n  if (obj.date) {\n    obj.expiration = {\n      createdBeforeDate: obj.date\n    };\n  }\n}\n\nfunction checkDaysAndDate(obj, key) {\n  const { days, createdBeforeDate } = obj;\n  if (!days && !createdBeforeDate) {\n    throw new Error(`${key} must includes days or createdBeforeDate`);\n  } else if (days && !/^[1-9][0-9]*$/.test(days)) {\n    throw new Error('days must be a positive integer');\n  } else if (createdBeforeDate && !/\\d{4}-\\d{2}-\\d{2}T00:00:00.000Z/.test(createdBeforeDate)) {\n    throw new Error('createdBeforeDate must be date and conform to iso8601 format');\n  }\n}\n\nfunction handleCheckTag(tag) {\n  if (!isArray(tag) && !isObject(tag)) {\n    throw new Error('tag must be Object or Array');\n  }\n  tag = isObject(tag) ? [tag] : tag;\n  const tagObj = {};\n  const tagClone = deepCopy(tag);\n  tagClone.forEach((v) => {\n    tagObj[v.key] = v.value;\n  });\n\n  checkObjectTag(tagObj);\n}\n\nfunction checkRule(rule) {\n  if (rule.id && getStrBytesCount(rule.id) > 255) throw new Error('ID is composed of 255 bytes at most');\n\n  if (rule.prefix === undefined) throw new Error('Rule must includes prefix');\n\n  if (!['Enabled', 'Disabled'].includes(rule.status)) throw new Error('Status must be  Enabled or Disabled');\n\n  if (rule.transition) {\n    if (!['IA', 'Archive'].includes(rule.transition.storageClass)) throw new Error('StorageClass must be  IA or Archive');\n    checkDaysAndDate(rule.transition, 'Transition');\n  }\n\n  if (rule.expiration) {\n    if (!rule.expiration.expiredObjectDeleteMarker) {\n      checkDaysAndDate(rule.expiration, 'Expiration');\n    } else if (rule.expiration.days || rule.expiration.createdBeforeDate) {\n      throw new Error('expiredObjectDeleteMarker cannot be used with days or createdBeforeDate');\n    }\n  }\n\n  if (rule.abortMultipartUpload) {\n    checkDaysAndDate(rule.abortMultipartUpload, 'AbortMultipartUpload');\n  }\n\n  if (!rule.expiration && !rule.abortMultipartUpload && !rule.transition && !rule.noncurrentVersionTransition) {\n    throw new Error('Rule must includes expiration or abortMultipartUpload or transition or noncurrentVersionTransition');\n  }\n\n  if (rule.tag) {\n    if (rule.abortMultipartUpload) {\n      throw new Error('Tag cannot be used with abortMultipartUpload');\n    }\n    handleCheckTag(rule.tag);\n  }\n}\n\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepCopyWith = exports.deepCopy = void 0;\nconst isBuffer_1 = require(\"./isBuffer\");\nexports.deepCopy = (obj) => {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (isBuffer_1.isBuffer(obj)) {\n        return obj.slice();\n    }\n    const copy = Array.isArray(obj) ? [] : {};\n    Object.keys(obj).forEach((key) => {\n        copy[key] = exports.deepCopy(obj[key]);\n    });\n    return copy;\n};\nexports.deepCopyWith = (obj, customizer) => {\n    function deepCopyWithHelper(value, innerKey, innerObject) {\n        const result = customizer(value, innerKey, innerObject);\n        if (result !== undefined)\n            return result;\n        if (value === null || typeof value !== 'object') {\n            return value;\n        }\n        if (isBuffer_1.isBuffer(value)) {\n            return value.slice();\n        }\n        const copy = Array.isArray(value) ? [] : {};\n        Object.keys(value).forEach((k) => {\n            copy[k] = deepCopyWithHelper(value[k], k, value);\n        });\n        return copy;\n    }\n    if (customizer) {\n        return deepCopyWithHelper(obj, '', null);\n    }\n    else {\n        return exports.deepCopy(obj);\n    }\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStrBytesCount = void 0;\nfunction getStrBytesCount(str) {\n    let bytesCount = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charAt(i);\n        if (/^[\\u00-\\uff]$/.test(c)) {\n            bytesCount += 1;\n        }\n        else {\n            bytesCount += 2;\n        }\n    }\n    return bytesCount;\n}\nexports.getStrBytesCount = getStrBytesCount;\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n\nproto.deleteBucketLifecycle = async function deleteBucketLifecycle(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('DELETE', name, 'lifecycle', options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * getBucketPolicy\n * @param {String} bucketName - bucket name\n * @param {Object} options\n */\n\nproto.getBucketPolicy = async function getBucketPolicy(bucketName, options = {}) {\n  _checkBucketName(bucketName);\n\n  const params = this._bucketRequestParams('GET', bucketName, 'policy', options);\n\n  const result = await this.request(params);\n  params.successStatuses = [200];\n  let policy = null;\n\n  if (result.res.status === 200) {\n    policy = JSON.parse(result.res.data.toString());\n  }\n\n  return {\n    policy,\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { policy2Str } = require('../utils/policy2Str');\nconst { isObject } = require('../utils/isObject');\n\nconst proto = exports;\n/**\n * putBucketPolicy\n * @param {String} bucketName - bucket name\n * @param {Object} policy - bucket policy\n * @param {Object} options\n */\n\nproto.putBucketPolicy = async function putBucketPolicy(bucketName, policy, options = {}) {\n  _checkBucketName(bucketName);\n\n  if (!isObject(policy)) {\n    throw new Error('policy is not Object');\n  }\n  const params = this._bucketRequestParams('PUT', bucketName, 'policy', options);\n  params.content = policy2Str(policy);\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * deleteBucketPolicy\n * @param {String} bucketName - bucket name\n * @param {Object} options\n */\n\nproto.deleteBucketPolicy = async function deleteBucketPolicy(bucketName, options = {}) {\n  _checkBucketName(bucketName);\n\n  const params = this._bucketRequestParams('DELETE', bucketName, 'policy', options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n\n  return {\n    status: result.status,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\n\nconst proto = exports;\n/**\n * getBucketVersioning\n * @param {String} bucketName - bucket name\n */\n\nproto.getBucketVersioning = async function getBucketVersioning(bucketName, options) {\n  _checkBucketName(bucketName);\n  const params = this._bucketRequestParams('GET', bucketName, 'versioning', options);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n  const result = await this.request(params);\n\n  const versionStatus = result.data.Status;\n  return {\n    status: result.status,\n    versionStatus,\n    res: result.res\n  };\n};\n","const { checkBucketName: _checkBucketName } = require('../utils/checkBucketName');\nconst { obj2xml } = require('../utils/obj2xml');\n\nconst proto = exports;\n/**\n * putBucketVersioning\n * @param {String} name - bucket name\n * @param {String} status\n * @param {Object} options\n */\n\nproto.putBucketVersioning = async function putBucketVersioning(name, status, options = {}) {\n  _checkBucketName(name);\n  if (!['Enabled', 'Suspended'].includes(status)) {\n    throw new Error('status must be Enabled or Suspended');\n  }\n  const params = this._bucketRequestParams('PUT', name, 'versioning', options);\n\n  const paramXMLObj = {\n    VersioningConfiguration: {\n      Status: status\n    }\n  };\n\n  params.mime = 'xml';\n  params.content = obj2xml(paramXMLObj, {\n    headers: true\n  });\n\n  const result = await this.request(params);\n  return {\n    res: result.res,\n    status: result.status\n  };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBucketInventory = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nconst formatInventoryConfig_1 = require(\"../utils/formatInventoryConfig\");\n/**\n * getBucketInventory\n * @param {String} bucketName - bucket name\n * @param {String} inventoryId\n * @param {Object} options\n */\nasync function getBucketInventory(bucketName, inventoryId, options = {}) {\n    const subres = Object.assign({ inventory: '', inventoryId }, options.subres);\n    checkBucketName_1.checkBucketName(bucketName);\n    const params = this._bucketRequestParams('GET', bucketName, subres, options);\n    params.successStatuses = [200];\n    params.xmlResponse = true;\n    const result = await this.request(params);\n    return {\n        status: result.status,\n        res: result.res,\n        inventory: formatInventoryConfig_1.formatInventoryConfig(result.data)\n    };\n}\nexports.getBucketInventory = getBucketInventory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatInventoryConfig = void 0;\nconst dataFix_1 = require(\"../utils/dataFix\");\nconst isObject_1 = require(\"../utils/isObject\");\nconst isArray_1 = require(\"../utils/isArray\");\nconst formatObjKey_1 = require(\"../utils/formatObjKey\");\nfunction formatInventoryConfig(inventoryConfig, toArray = false) {\n    if (toArray && isObject_1.isObject(inventoryConfig))\n        inventoryConfig = [inventoryConfig];\n    if (isArray_1.isArray(inventoryConfig)) {\n        inventoryConfig = inventoryConfig.map(formatFn);\n    }\n    else {\n        inventoryConfig = formatFn(inventoryConfig);\n    }\n    return inventoryConfig;\n}\nexports.formatInventoryConfig = formatInventoryConfig;\nfunction formatFn(_) {\n    dataFix_1.dataFix(_, { bool: ['IsEnabled'] }, conf => {\n        var _a, _b;\n        // prefix\n        conf.prefix = conf.Filter.Prefix;\n        delete conf.Filter;\n        // OSSBucketDestination\n        conf.OSSBucketDestination = conf.Destination.OSSBucketDestination;\n        // OSSBucketDestination.rolename\n        conf.OSSBucketDestination.rolename = conf.OSSBucketDestination.RoleArn.replace(/.*\\//, '');\n        delete conf.OSSBucketDestination.RoleArn;\n        // OSSBucketDestination.bucket\n        conf.OSSBucketDestination.bucket = conf.OSSBucketDestination.Bucket.replace(/.*:::/, '');\n        delete conf.OSSBucketDestination.Bucket;\n        delete conf.Destination;\n        // frequency\n        conf.frequency = conf.Schedule.Frequency;\n        delete conf.Schedule.Frequency;\n        // optionalFields\n        if (((_a = conf === null || conf === void 0 ? void 0 : conf.OptionalFields) === null || _a === void 0 ? void 0 : _a.Field) && !isArray_1.isArray((_b = conf.OptionalFields) === null || _b === void 0 ? void 0 : _b.Field))\n            conf.OptionalFields.Field = [conf.OptionalFields.Field];\n    });\n    // firstLowerCase\n    _ = formatObjKey_1.formatObjKey(_, 'firstLowerCase', { exclude: ['OSSBucketDestination', 'SSE-OSS', 'SSE-KMS'] });\n    return _;\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dataFix = void 0;\nconst isObject_1 = require(\"./isObject\");\nconst TRUE = ['true', 'TRUE', '1', 1];\nconst FALSE = ['false', 'FALSE', '0', 0];\nfunction dataFix(o, conf, finalKill) {\n    if (!isObject_1.isObject(o))\n        return;\n    const { remove = [], rename = {}, camel = [], bool = [], lowerFirst = false, } = conf;\n    // 删除不需要的数据\n    remove.forEach(v => delete o[v]);\n    // 重命名\n    Object.entries(rename).forEach(v => {\n        if (!o[v[0]])\n            return;\n        if (o[v[1]])\n            return;\n        o[v[1]] = o[v[0]];\n        delete o[v[0]];\n    });\n    // 驼峰化\n    camel.forEach(v => {\n        if (!o[v])\n            return;\n        const afterKey = v\n            .replace(/^(.)/, $0 => $0.toLowerCase())\n            .replace(/-(\\w)/g, (_, $1) => $1.toUpperCase());\n        if (o[afterKey])\n            return;\n        o[afterKey] = o[v];\n        // todo 暂时兼容以前数据，不做删除\n        // delete o[v];\n    });\n    // 转换值为布尔值\n    bool.forEach(v => {\n        o[v] = fixBool(o[v]);\n    });\n    // finalKill\n    if (typeof finalKill === 'function') {\n        finalKill(o);\n    }\n    // 首字母转小写\n    fixLowerFirst(o, lowerFirst);\n    return dataFix;\n}\nexports.dataFix = dataFix;\nfunction fixBool(value) {\n    if (!value)\n        return false;\n    if (TRUE.includes(value))\n        return true;\n    return FALSE.includes(value) ? false : value;\n}\nfunction fixLowerFirst(o, lowerFirst) {\n    if (lowerFirst) {\n        Object.keys(o).forEach(key => {\n            const lowerK = key.replace(/^\\w/, match => match.toLowerCase());\n            if (typeof o[lowerK] === 'undefined') {\n                o[lowerK] = o[key];\n                delete o[key];\n            }\n        });\n    }\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deleteBucketInventory = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\n/**\n * deleteBucketInventory\n * @param {String} bucketName - bucket name\n * @param {String} inventoryId\n * @param {Object} options\n */\nasync function deleteBucketInventory(bucketName, inventoryId, options = {}) {\n    const subres = Object.assign({ inventory: '', inventoryId }, options.subres);\n    checkBucketName_1.checkBucketName(bucketName);\n    const params = this._bucketRequestParams('DELETE', bucketName, subres, options);\n    params.successStatuses = [204];\n    const result = await this.request(params);\n    return {\n        status: result.status,\n        res: result.res,\n    };\n}\nexports.deleteBucketInventory = deleteBucketInventory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.listBucketInventory = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nconst formatInventoryConfig_1 = require(\"../utils/formatInventoryConfig\");\n/**\n * listBucketInventory\n * @param {String} bucketName - bucket name\n * @param {String} inventoryId\n * @param {Object} options\n */\nasync function listBucketInventory(bucketName, options = {}) {\n    const { continuationToken } = options;\n    const subres = Object.assign({ inventory: '' }, continuationToken && { 'continuation-token': continuationToken }, options.subres);\n    checkBucketName_1.checkBucketName(bucketName);\n    const params = this._bucketRequestParams('GET', bucketName, subres, options);\n    params.successStatuses = [200];\n    params.xmlResponse = true;\n    const result = await this.request(params);\n    const { data, res, status } = result;\n    return {\n        isTruncated: data.IsTruncated === 'true',\n        nextContinuationToken: data.NextContinuationToken,\n        inventoryList: formatInventoryConfig_1.formatInventoryConfig(data.InventoryConfiguration, true),\n        status,\n        res,\n    };\n}\nexports.listBucketInventory = listBucketInventory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.putBucketInventory = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nconst obj2xml_1 = require(\"../utils/obj2xml\");\n/**\n * putBucketInventory\n * @param {String} bucketName - bucket name\n * @param {Inventory} inventory\n * @param {Object} options\n */\nasync function putBucketInventory(bucketName, inventory, options = {}) {\n    const subres = Object.assign({ inventory: '', inventoryId: inventory.id }, options.subres);\n    checkBucketName_1.checkBucketName(bucketName);\n    const { OSSBucketDestination, optionalFields, includedObjectVersions } = inventory;\n    const destinationBucketPrefix = 'acs:oss:::';\n    const rolePrefix = `acs:ram::${OSSBucketDestination.accountId}:role/`;\n    const paramXMLObj = {\n        InventoryConfiguration: {\n            Id: inventory.id,\n            IsEnabled: inventory.isEnabled,\n            Filter: {\n                Prefix: inventory.prefix || '',\n            },\n            Destination: {\n                OSSBucketDestination: {\n                    Format: OSSBucketDestination.format,\n                    AccountId: OSSBucketDestination.accountId,\n                    RoleArn: `${rolePrefix}${OSSBucketDestination.rolename}`,\n                    Bucket: `${destinationBucketPrefix}${OSSBucketDestination.bucket}`,\n                    Prefix: OSSBucketDestination.prefix || '',\n                    Encryption: OSSBucketDestination.encryption || '',\n                },\n            },\n            Schedule: {\n                Frequency: inventory.frequency,\n            },\n            IncludedObjectVersions: includedObjectVersions,\n            OptionalFields: {\n                Field: (optionalFields === null || optionalFields === void 0 ? void 0 : optionalFields.field) || [],\n            },\n        },\n    };\n    const paramXML = obj2xml_1.obj2xml(paramXMLObj, {\n        headers: true,\n        firstUpperCase: true,\n    });\n    const params = this._bucketRequestParams('PUT', bucketName, subres, options);\n    params.successStatuses = [200];\n    params.mime = 'xml';\n    params.content = paramXML;\n    const result = await this.request(params);\n    return {\n        status: result.status,\n        res: result.res,\n    };\n}\nexports.putBucketInventory = putBucketInventory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abortBucketWorm = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nasync function abortBucketWorm(name, options) {\n    checkBucketName_1.checkBucketName(name);\n    const params = this._bucketRequestParams('DELETE', name, 'worm', options);\n    const result = await this.request(params);\n    return {\n        res: result.res,\n        status: result.status\n    };\n}\nexports.abortBucketWorm = abortBucketWorm;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completeBucketWorm = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nasync function completeBucketWorm(name, wormId, options) {\n    checkBucketName_1.checkBucketName(name);\n    const params = this._bucketRequestParams('POST', name, { wormId }, options);\n    const result = await this.request(params);\n    return {\n        res: result.res,\n        status: result.status\n    };\n}\nexports.completeBucketWorm = completeBucketWorm;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendBucketWorm = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nconst obj2xml_1 = require(\"../utils/obj2xml\");\nasync function extendBucketWorm(name, wormId, days, options) {\n    checkBucketName_1.checkBucketName(name);\n    const params = this._bucketRequestParams('POST', name, { wormExtend: '', wormId }, options);\n    const paramlXMLObJ = {\n        ExtendWormConfiguration: {\n            RetentionPeriodInDays: days\n        }\n    };\n    params.mime = 'xml';\n    params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });\n    params.successStatuses = [200];\n    const result = await this.request(params);\n    return {\n        res: result.res,\n        status: result.status\n    };\n}\nexports.extendBucketWorm = extendBucketWorm;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBucketWorm = void 0;\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nconst dataFix_1 = require(\"../utils/dataFix\");\nasync function getBucketWorm(name, options) {\n    checkBucketName_1.checkBucketName(name);\n    const params = this._bucketRequestParams('GET', name, 'worm', options);\n    params.successStatuses = [200];\n    params.xmlResponse = true;\n    const result = await this.request(params);\n    dataFix_1.dataFix(result.data, {\n        lowerFirst: true,\n        rename: {\n            RetentionPeriodInDays: 'days'\n        }\n    });\n    return Object.assign(Object.assign({}, result.data), { res: result.res, status: result.status });\n}\nexports.getBucketWorm = getBucketWorm;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.initiateBucketWorm = void 0;\nconst obj2xml_1 = require(\"../utils/obj2xml\");\nconst checkBucketName_1 = require(\"../utils/checkBucketName\");\nasync function initiateBucketWorm(name, days, options) {\n    checkBucketName_1.checkBucketName(name);\n    const params = this._bucketRequestParams('POST', name, 'worm', options);\n    const paramlXMLObJ = {\n        InitiateWormConfiguration: {\n            RetentionPeriodInDays: days\n        }\n    };\n    params.mime = 'xml';\n    params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });\n    params.successStatuses = [200];\n    const result = await this.request(params);\n    return {\n        res: result.res,\n        wormId: result.res.headers['x-oss-worm-id'],\n        status: result.status\n    };\n}\nexports.initiateBucketWorm = initiateBucketWorm;\n","\n\nconst assert = require('assert');\nconst { isArray } = require('./common/utils/isArray');\nconst { checkBucketName: _checkBucketName } = require('../lib/common/utils/checkBucketName');\nconst { formatTag } = require('../lib/common/utils/formatTag');\n\nconst proto = exports;\n\n\nfunction toArray(obj) {\n  if (!obj) return [];\n  if (isArray(obj)) return obj;\n  return [obj];\n}\n\n/**\n * Bucket opertaions\n */\n\nproto.listBuckets = async function listBuckets(query = {}, options = {}) {\n  // prefix, marker, max-keys\n\n  const { subres = {} } = query;\n  const rest = {};\n  for (const key in query) {\n    if (key !== 'subres') {\n      rest[key] = query[key];\n    }\n  }\n  const params = this._bucketRequestParams(\n    'GET',\n    '',\n    Object.assign(subres, options.subres),\n    options\n  );\n\n  params.query = rest;\n\n  const result = await this.request(params);\n\n  if (result.status === 200) {\n    const data = await this.parseXML(result.data);\n    let buckets = data.Buckets || null;\n    if (buckets) {\n      if (buckets.Bucket) {\n        buckets = buckets.Bucket;\n      }\n      if (!isArray(buckets)) {\n        buckets = [buckets];\n      }\n      buckets = buckets.map(item => ({\n        name: item.Name,\n        region: item.Location,\n        creationDate: item.CreationDate,\n        StorageClass: item.StorageClass,\n        tag: formatTag(item)\n      }));\n    }\n    return {\n      buckets,\n      owner: {\n        id: data.Owner.ID,\n        displayName: data.Owner.DisplayName\n      },\n      isTruncated: data.IsTruncated === 'true',\n      nextMarker: data.NextMarker || null,\n      res: result.res\n    };\n  }\n\n  throw await this.requestError(result);\n};\n\nproto.useBucket = function useBucket(name) {\n  _checkBucketName(name);\n  return this.setBucket(name);\n};\n\nproto.setBucket = function useBucket(name) {\n  _checkBucketName(name);\n  this.options.bucket = name;\n  return this;\n};\n\nproto.getBucket = function getBucket() {\n  return this.options.bucket;\n};\n\nproto.getBucketLocation = async function getBucketLocation(name, options) {\n  _checkBucketName(name);\n  name = name || this.getBucket();\n  const params = this._bucketRequestParams('GET', name, 'location', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  return {\n    location: result.data,\n    res: result.res\n  };\n};\n\nproto.getBucketInfo = async function getBucketInfo(name, options) {\n  _checkBucketName(name);\n  name = name || this.getBucket();\n  const params = this._bucketRequestParams('GET', name, 'bucketInfo', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  return {\n    bucket: result.data.Bucket,\n    res: result.res\n  };\n};\n\nproto.deleteBucket = async function deleteBucket(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('DELETE', name, '', options);\n  const result = await this.request(params);\n  if (result.status === 200 || result.status === 204) {\n    return {\n      res: result.res\n    };\n  }\n  throw await this.requestError(result);\n};\n\n// acl\n\nproto.putBucketACL = async function putBucketACL(name, acl, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('PUT', name, 'acl', options);\n  params.headers = {\n    'x-oss-acl': acl\n  };\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    bucket: (result.headers.location && result.headers.location.substring(1)) || null,\n    res: result.res\n  };\n};\n\nproto.getBucketACL = async function getBucketACL(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'acl', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  return {\n    acl: result.data.AccessControlList.Grant,\n    owner: {\n      id: result.data.Owner.ID,\n      displayName: result.data.Owner.DisplayName\n    },\n    res: result.res\n  };\n};\n\n// logging\n\nproto.putBucketLogging = async function putBucketLogging(name, prefix, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('PUT', name, 'logging', options);\n  let xml = `${'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<BucketLoggingStatus>\\n' +\n    '<LoggingEnabled>\\n<TargetBucket>'}${name}</TargetBucket>\\n`;\n  if (prefix) {\n    xml += `<TargetPrefix>${prefix}</TargetPrefix>\\n`;\n  }\n  xml += '</LoggingEnabled>\\n</BucketLoggingStatus>';\n  params.content = xml;\n  params.mime = 'xml';\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\nproto.getBucketLogging = async function getBucketLogging(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'logging', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  const enable = result.data.LoggingEnabled;\n  return {\n    enable: !!enable,\n    prefix: (enable && enable.TargetPrefix) || null,\n    res: result.res\n  };\n};\n\nproto.deleteBucketLogging = async function deleteBucketLogging(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('DELETE', name, 'logging', options);\n  params.successStatuses = [204, 200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\nproto.putBucketCORS = async function putBucketCORS(name, rules, options) {\n  _checkBucketName(name);\n  rules = rules || [];\n  assert(rules.length, 'rules is required');\n  rules.forEach((rule) => {\n    assert(rule.allowedOrigin, 'allowedOrigin is required');\n    assert(rule.allowedMethod, 'allowedMethod is required');\n  });\n\n  const params = this._bucketRequestParams('PUT', name, 'cors', options);\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<CORSConfiguration>';\n  const parseOrigin = (val) => {\n    xml += `<AllowedOrigin>${val}</AllowedOrigin>`;\n  };\n  const parseMethod = (val) => {\n    xml += `<AllowedMethod>${val}</AllowedMethod>`;\n  };\n  const parseHeader = (val) => {\n    xml += `<AllowedHeader>${val}</AllowedHeader>`;\n  };\n  const parseExposeHeader = (val) => {\n    xml += `<ExposeHeader>${val}</ExposeHeader>`;\n  };\n  for (let i = 0, l = rules.length; i < l; i++) {\n    const rule = rules[i];\n    xml += '<CORSRule>';\n\n    toArray(rule.allowedOrigin).forEach(parseOrigin);\n    toArray(rule.allowedMethod).forEach(parseMethod);\n    toArray(rule.allowedHeader).forEach(parseHeader);\n    toArray(rule.exposeHeader).forEach(parseExposeHeader);\n    if (rule.maxAgeSeconds) {\n      xml += `<MaxAgeSeconds>${rule.maxAgeSeconds}</MaxAgeSeconds>`;\n    }\n    xml += '</CORSRule>';\n  }\n  xml += '</CORSConfiguration>';\n  params.content = xml;\n  params.mime = 'xml';\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\nproto.getBucketCORS = async function getBucketCORS(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'cors', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  const rules = [];\n  if (result.data && result.data.CORSRule) {\n    let { CORSRule } = result.data;\n    if (!isArray(CORSRule)) CORSRule = [CORSRule];\n    CORSRule.forEach((rule) => {\n      const r = {};\n      Object.keys(rule).forEach((key) => {\n        r[key.slice(0, 1).toLowerCase() + key.slice(1, key.length)] = rule[key];\n      });\n      rules.push(r);\n    });\n  }\n  return {\n    rules,\n    res: result.res\n  };\n};\n\nproto.deleteBucketCORS = async function deleteBucketCORS(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('DELETE', name, 'cors', options);\n  params.successStatuses = [204];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\n// referer\n\nproto.putBucketReferer = async function putBucketReferer(name, allowEmpty, referers, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('PUT', name, 'referer', options);\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<RefererConfiguration>\\n';\n  xml += `  <AllowEmptyReferer>${allowEmpty ? 'true' : 'false'}</AllowEmptyReferer>\\n`;\n  if (referers && referers.length > 0) {\n    xml += '  <RefererList>\\n';\n    for (let i = 0; i < referers.length; i++) {\n      xml += `    <Referer>${referers[i]}</Referer>\\n`;\n    }\n    xml += '  </RefererList>\\n';\n  } else {\n    xml += '  <RefererList />\\n';\n  }\n  xml += '</RefererConfiguration>';\n  params.content = xml;\n  params.mime = 'xml';\n  params.successStatuses = [200];\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\nproto.getBucketReferer = async function getBucketReferer(name, options) {\n  _checkBucketName(name);\n  const params = this._bucketRequestParams('GET', name, 'referer', options);\n  params.successStatuses = [200];\n  params.xmlResponse = true;\n  const result = await this.request(params);\n  let referers = result.data.RefererList.Referer || null;\n  if (referers) {\n    if (!isArray(referers)) {\n      referers = [referers];\n    }\n  }\n  return {\n    allowEmpty: result.data.AllowEmptyReferer === 'true',\n    referers,\n    res: result.res\n  };\n};\n\nproto.deleteBucketReferer = async function deleteBucketReferer(name, options) {\n  _checkBucketName(name);\n  return await this.putBucketReferer(name, true, null, options);\n};\n\n// private apis\n\nproto._bucketRequestParams = function _bucketRequestParams(method, bucket, subres, options) {\n  return {\n    method,\n    bucket,\n    subres,\n    timeout: options && options.timeout,\n    ctx: options && options.ctx\n  };\n};\n","\nconst fs = require('fs');\nconst is = require('is-type-of');\nconst util = require('util');\nconst path = require('path');\nconst mime = require('mime');\nconst { isFile } = require('./common/utils/isFile');\nconst { isArray } = require('./common/utils/isArray');\nconst { isBuffer } = require('./common/utils/isBuffer');\n\nconst proto = exports;\n\n/**\n * Multipart operations\n */\n\n/**\n * Upload a file to OSS using multipart uploads\n * @param {String} name\n * @param {String|File|Buffer} file\n * @param {Object} options\n *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64\n *        {String} options.callback.url the OSS sends a callback request to this URL\n *        {String} options.callback.host The host header value for initiating callback requests\n *        {String} options.callback.body The value of the request body when a callback is initiated\n *        {String} options.callback.contentType The Content-Type of the callback requests initiatiated\n *        {Object} options.callback.customValue Custom parameters are a map of key-values, e.g:\n *                  customValue = {\n *                    key1: 'value1',\n *                    key2: 'value2'\n *                  }\n */\nproto.multipartUpload = async function multipartUpload(name, file, options) {\n  this.resetCancelFlag();\n  options = options || {};\n  if (options.checkpoint && options.checkpoint.uploadId) {\n    return await this._resumeMultipart(options.checkpoint, options);\n  }\n\n  const minPartSize = 100 * 1024;\n  if (!options.mime) {\n    if (isFile(file)) {\n      options.mime = mime.getType(path.extname(file.name));\n    } else if (isBuffer(file)) {\n      options.mime = '';\n    } else {\n      options.mime = mime.getType(path.extname(file));\n    }\n  }\n  options.headers = options.headers || {};\n  this._convertMetaToHeaders(options.meta, options.headers);\n\n  const fileSize = await this._getFileSize(file);\n  if (fileSize < minPartSize) {\n    const stream = this._createStream(file, 0, fileSize);\n    options.contentLength = fileSize;\n\n    const result = await this.putStream(name, stream, options);\n    if (options && options.progress) {\n      await options.progress(1);\n    }\n\n    const ret = {\n      res: result.res,\n      bucket: this.options.bucket,\n      name,\n      etag: result.res.headers.etag\n    };\n\n    if ((options.headers && options.headers['x-oss-callback']) || options.callback) {\n      ret.data = result.data;\n    }\n\n    return ret;\n  }\n\n  if (options.partSize && !(parseInt(options.partSize, 10) === options.partSize)) {\n    throw new Error('partSize must be int number');\n  }\n\n  if (options.partSize && options.partSize < minPartSize) {\n    throw new Error(`partSize must not be smaller than ${minPartSize}`);\n  }\n\n  const initResult = await this.initMultipartUpload(name, options);\n  const { uploadId } = initResult;\n  const partSize = this._getPartSize(fileSize, options.partSize);\n\n  const checkpoint = {\n    file,\n    name,\n    fileSize,\n    partSize,\n    uploadId,\n    doneParts: []\n  };\n\n  if (options && options.progress) {\n    await options.progress(0, checkpoint, initResult.res);\n  }\n\n  return await this._resumeMultipart(checkpoint, options);\n};\n\n/*\n * Resume multipart upload from checkpoint. The checkpoint will be\n * updated after each successful part upload.\n * @param {Object} checkpoint the checkpoint\n * @param {Object} options\n */\nproto._resumeMultipart = async function _resumeMultipart(checkpoint, options) {\n  if (this.isCancel()) {\n    throw this._makeCancelEvent();\n  }\n  const {\n    file, fileSize, partSize, uploadId, doneParts, name\n  } = checkpoint;\n\n  const partOffs = this._divideParts(fileSize, partSize);\n  const numParts = partOffs.length;\n\n  let uploadPartJob = function uploadPartJob(self, partNo) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (!self.isCancel()) {\n          const pi = partOffs[partNo - 1];\n          const stream = self._createStream(file, pi.start, pi.end);\n          const data = {\n            stream,\n            size: pi.end - pi.start\n          };\n\n          if (isArray(self.multipartUploadStreams)) {\n            self.multipartUploadStreams.push(data.stream);\n          } else {\n            self.multipartUploadStreams = [data.stream];\n          }\n\n          const removeStreamFromMultipartUploadStreams = function () {\n            if (!stream.destroyed) {\n              stream.destroy();\n            }\n            const index = self.multipartUploadStreams.indexOf(stream);\n            if (index !== -1) {\n              self.multipartUploadStreams.splice(index, 1);\n            }\n          };\n\n          stream.on('close', removeStreamFromMultipartUploadStreams);\n          stream.on('error', removeStreamFromMultipartUploadStreams);\n\n          let result;\n          try {\n            result = await self._uploadPart(name, uploadId, partNo, data);\n          } catch (error) {\n            removeStreamFromMultipartUploadStreams();\n            if (error.status === 404) {\n              throw self._makeAbortEvent();\n            }\n            throw error;\n          }\n          if (!self.isCancel()) {\n            doneParts.push({\n              number: partNo,\n              etag: result.res.headers.etag\n            });\n            checkpoint.doneParts = doneParts;\n\n            if (options.progress) {\n              await options.progress(doneParts.length / numParts, checkpoint, result.res);\n            }\n          }\n        }\n        resolve();\n      } catch (err) {\n        err.partNum = partNo;\n        reject(err);\n      }\n    });\n  };\n\n  const all = Array.from(new Array(numParts), (x, i) => i + 1);\n  const done = doneParts.map(p => p.number);\n  const todo = all.filter(p => done.indexOf(p) < 0);\n\n  const defaultParallel = 5;\n  const parallel = options.parallel || defaultParallel;\n\n  if (this.checkBrowserAndVersion('Internet Explorer', '10') || parallel === 1) {\n    for (let i = 0; i < todo.length; i++) {\n      if (this.isCancel()) {\n        throw this._makeCancelEvent();\n      }\n      /* eslint no-await-in-loop: [0] */\n      await uploadPartJob(this, todo[i]);\n    }\n  } else {\n    // upload in parallel\n    const jobErr = await this._parallelNode(todo, parallel, uploadPartJob);\n\n    const abortEvent = jobErr.find(err => err.name === 'abort');\n    if (abortEvent) throw abortEvent;\n\n    if (this.isCancel()) {\n      uploadPartJob = null;\n      throw this._makeCancelEvent();\n    }\n\n    if (jobErr && jobErr.length > 0) {\n      jobErr[0].message = `Failed to upload some parts with error: ${jobErr[0].toString()} part_num: ${jobErr[0].partNum}`;\n      throw jobErr[0];\n    }\n  }\n\n  return await this.completeMultipartUpload(name, uploadId, doneParts, options);\n};\n\n/**\n * Get file size\n */\nproto._getFileSize = async function _getFileSize(file) {\n  if (isBuffer(file)) {\n    return file.length;\n  } else if (isFile(file)) {\n    return file.size;\n  } if (is.string(file)) {\n    const stat = await this._statFile(file);\n    return stat.size;\n  }\n\n  throw new Error('_getFileSize requires Buffer/File/String.');\n};\n\n/*\n * Readable stream for Web File\n */\nconst { Readable } = require('stream');\n\nfunction WebFileReadStream(file, options) {\n  if (!(this instanceof WebFileReadStream)) {\n    return new WebFileReadStream(file, options);\n  }\n\n  Readable.call(this, options);\n\n  this.file = file;\n  this.reader = new FileReader();\n  this.start = 0;\n  this.finish = false;\n  this.fileBuffer = null;\n}\nutil.inherits(WebFileReadStream, Readable);\n\nWebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size) {\n  if (this.fileBuffer) {\n    let pushRet = true;\n    while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {\n      const { start } = this;\n      let end = start + size;\n      end = end > this.fileBuffer.length ? this.fileBuffer.length : end;\n      this.start = end;\n      pushRet = this.push(this.fileBuffer.slice(start, end));\n    }\n  }\n};\n\nWebFileReadStream.prototype._read = function _read(size) {\n  if ((this.file && this.start >= this.file.size) ||\n      (this.fileBuffer && this.start >= this.fileBuffer.length) ||\n      (this.finish) || (this.start === 0 && !this.file)) {\n    if (!this.finish) {\n      this.fileBuffer = null;\n      this.finish = true;\n    }\n    this.push(null);\n    return;\n  }\n\n  const defaultReadSize = 16 * 1024;\n  size = size || defaultReadSize;\n\n  const that = this;\n  this.reader.onload = function (e) {\n    that.fileBuffer = Buffer.from(new Uint8Array(e.target.result));\n    that.file = null;\n    that.readFileAndPush(size);\n  };\n  this.reader.onerror = function onload(e) {\n    const error = e.srcElement && e.srcElement.error;\n    if (error) {\n      throw error;\n    }\n    throw e;\n  };\n\n  if (this.start === 0) {\n    this.reader.readAsArrayBuffer(this.file);\n  } else {\n    this.readFileAndPush(size);\n  }\n};\n\nproto._createStream = function _createStream(file, start, end) {\n  if (is.readableStream(file)) {\n    return file;\n  } else if (isFile(file)) {\n    return new WebFileReadStream(file.slice(start, end));\n  } else if (isBuffer(file)) {\n    const iterable = file.subarray(start, end);\n    // we can't use Readable.from() since it is only support in Node v10\n    return new Readable({\n      read() {\n        this.push(iterable);\n        this.push(null);\n      }\n    });\n  } else if (is.string(file)) {\n    return fs.createReadStream(file, {\n      start,\n      end: end - 1\n    });\n  }\n  throw new Error('_createStream requires Buffer/File/String.');\n};\n\nproto._getPartSize = function _getPartSize(fileSize, partSize) {\n  const maxNumParts = 10 * 1000;\n  const defaultPartSize = 1 * 1024 * 1024;\n\n  if (!partSize) partSize = defaultPartSize;\n  const safeSize = Math.ceil(fileSize / maxNumParts);\n\n  if (partSize < safeSize) {\n    partSize = safeSize;\n    console.warn(`partSize has been set to ${partSize}, because the partSize you provided causes partNumber to be greater than 10,000`);\n  }\n  return partSize;\n};\n\nproto._divideParts = function _divideParts(fileSize, partSize) {\n  const numParts = Math.ceil(fileSize / partSize);\n\n  const partOffs = [];\n  for (let i = 0; i < numParts; i++) {\n    const start = partSize * i;\n    const end = Math.min(start + partSize, fileSize);\n\n    partOffs.push({\n      start,\n      end\n    });\n  }\n\n  return partOffs;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFile = void 0;\nexports.isFile = (obj) => {\n    return typeof (File) !== 'undefined' && obj instanceof File;\n};\n","/**\n * Copyright(c) ali-sdk and other contributors.\n * MIT Licensed\n *\n * Authors:\n *   rockuw <rockuw@gmail.com> (http://rockuw.com)\n */\n\n\n/**\n * Module dependencies.\n */\n\nconst jstoxml = require('jstoxml');\nconst utility = require('utility');\nconst copy = require('copy-to');\nconst urlutil = require('url');\n\nconst proto = exports;\n\n/**\n * RTMP operations\n */\n\n/**\n * Create a live channel\n * @param {String} id the channel id\n * @param {Object} conf the channel configuration\n * @param {Object} options\n * @return {Object}\n */\nproto.putChannel = async function putChannel(id, conf, options) {\n  options = options || {};\n  options.subres = 'live';\n\n  const params = this._objectRequestParams('PUT', id, options);\n  params.xmlResponse = true;\n  params.content = jstoxml.toXML({\n    LiveChannelConfiguration: conf\n  });\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  let publishUrls = result.data.PublishUrls.Url;\n  if (!Array.isArray(publishUrls)) {\n    publishUrls = [publishUrls];\n  }\n  let playUrls = result.data.PlayUrls.Url;\n  if (!Array.isArray(playUrls)) {\n    playUrls = [playUrls];\n  }\n\n  return {\n    publishUrls,\n    playUrls,\n    res: result.res\n  };\n};\n\n/**\n * Get the channel info\n * @param {String} id the channel id\n * @param {Object} options\n * @return {Object}\n */\nproto.getChannel = async function getChannel(id, options) {\n  options = options || {};\n  options.subres = 'live';\n\n  const params = this._objectRequestParams('GET', id, options);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    data: result.data,\n    res: result.res\n  };\n};\n\n/**\n * Delete the channel\n * @param {String} id the channel id\n * @param {Object} options\n * @return {Object}\n */\nproto.deleteChannel = async function deleteChannel(id, options) {\n  options = options || {};\n  options.subres = 'live';\n\n  const params = this._objectRequestParams('DELETE', id, options);\n  params.successStatuses = [204];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n\n/**\n * Set the channel status\n * @param {String} id the channel id\n * @param {String} status the channel status\n * @param {Object} options\n * @return {Object}\n */\nproto.putChannelStatus = async function putChannelStatus(id, status, options) {\n  options = options || {};\n  options.subres = {\n    live: null,\n    status\n  };\n\n  const params = this._objectRequestParams('PUT', id, options);\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n\n/**\n * Get the channel status\n * @param {String} id the channel id\n * @param {Object} options\n * @return {Object}\n */\nproto.getChannelStatus = async function getChannelStatus(id, options) {\n  options = options || {};\n  options.subres = {\n    live: null,\n    comp: 'stat'\n  };\n\n  const params = this._objectRequestParams('GET', id, options);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    data: result.data,\n    res: result.res\n  };\n};\n\n/**\n * List the channels\n * @param {Object} query the query parameters\n *  filter options:\n *   - prefix {String}: the channel id prefix (returns channels with this prefix)\n *   - marker {String}: the channle id marker (returns channels after this id)\n *   - max-keys {Number}: max number of channels to return\n * @param {Object} options\n * @return {Object}\n */\nproto.listChannels = async function listChannels(query, options) {\n  // prefix, marker, max-keys\n\n  options = options || {};\n  options.subres = 'live';\n\n  const params = this._objectRequestParams('GET', '', options);\n  params.query = query;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  let channels = result.data.LiveChannel || [];\n  if (!Array.isArray(channels)) {\n    channels = [channels];\n  }\n\n  channels = channels.map((x) => {\n    x.PublishUrls = x.PublishUrls.Url;\n    if (!Array.isArray(x.PublishUrls)) {\n      x.PublishUrls = [x.PublishUrls];\n    }\n    x.PlayUrls = x.PlayUrls.Url;\n    if (!Array.isArray(x.PlayUrls)) {\n      x.PlayUrls = [x.PlayUrls];\n    }\n\n    return x;\n  });\n\n  return {\n    channels,\n    nextMarker: result.data.NextMarker || null,\n    isTruncated: result.data.IsTruncated === 'true',\n    res: result.res\n  };\n};\n\n/**\n * Get the channel history\n * @param {String} id the channel id\n * @param {Object} options\n * @return {Object}\n */\nproto.getChannelHistory = async function getChannelHistory(id, options) {\n  options = options || {};\n  options.subres = {\n    live: null,\n    comp: 'history'\n  };\n\n  const params = this._objectRequestParams('GET', id, options);\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  let records = result.data.LiveRecord || [];\n  if (!Array.isArray(records)) {\n    records = [records];\n  }\n  return {\n    records,\n    res: result.res\n  };\n};\n\n/**\n * Create vod playlist\n * @param {String} id the channel id\n * @param {String} name the playlist name\n * @param {Object} time the begin and end time\n *  time:\n *   - startTime {Number}: the begin time in epoch seconds\n *   - endTime {Number}: the end time in epoch seconds\n * @param {Object} options\n * @return {Object}\n */\nproto.createVod = async function createVod(id, name, time, options) {\n  options = options || {};\n  options.subres = {\n    vod: null\n  };\n  copy(time).to(options.subres);\n\n  const params = this._objectRequestParams('POST', `${id}/${name}`, options);\n  params.query = time;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res\n  };\n};\n\n/**\n * Get RTMP Url\n * @param {String} channelId the channel id\n * @param {Object} options\n *  options:\n *   - expires {Number}: expire time in seconds\n *   - params {Object}: the parameters such as 'playlistName'\n * @return {String} the RTMP url\n */\nproto.getRtmpUrl = function (channelId, options) {\n  options = options || {};\n  const expires = utility.timestamp() + (options.expires || 1800);\n  const res = {\n    bucket: this.options.bucket,\n    object: this._objectName(`live/${channelId}`)\n  };\n  const resource = `/${res.bucket}/${channelId}`;\n\n  options.params = options.params || {};\n  const query = Object.keys(options.params).sort().map(x => `${x}:${options.params[x]}\\n`).join('');\n\n  const stringToSign = `${expires}\\n${query}${resource}`;\n  const signature = this.signature(stringToSign);\n\n  const url = urlutil.parse(this._getReqUrl(res));\n  url.protocol = 'rtmp:';\n  url.query = {\n    OSSAccessKeyId: this.options.accessKeyId,\n    Expires: expires,\n    Signature: signature\n  };\n  copy(options.params).to(url.query);\n\n  return url.format();\n};\n","/* eslint-disable no-async-promise-executor */\n\nconst debug = require('debug')('ali-oss:multipart-copy');\nconst copy = require('copy-to');\n\nconst proto = exports;\n\n\n/**\n * Upload a part copy in a multipart from the source bucket/object\n * used with initMultipartUpload and completeMultipartUpload.\n * @param {String} name copy object name\n * @param {String} uploadId the upload id\n * @param {Number} partNo the part number\n * @param {String} range  like 0-102400  part size need to copy\n * @param {Object} sourceData\n *        {String} sourceData.sourceKey  the source object name\n *        {String} sourceData.sourceBucketName  the source bucket name\n * @param {Object} options\n */\n/* eslint max-len: [0] */\nproto.uploadPartCopy = async function uploadPartCopy(name, uploadId, partNo, range, sourceData, options = {}) {\n  options.headers = options.headers || {};\n  const versionId = options.versionId || (options.subres && options.subres.versionId) || null;\n  let copySource;\n  if (versionId) {\n    copySource = `/${sourceData.sourceBucketName}/${encodeURIComponent(sourceData.sourceKey)}?versionId=${versionId}`;\n  } else {\n    copySource = `/${sourceData.sourceBucketName}/${encodeURIComponent(sourceData.sourceKey)}`;\n  }\n\n  options.headers['x-oss-copy-source'] = copySource;\n  if (range) {\n    options.headers['x-oss-copy-source-range'] = `bytes=${range}`;\n  }\n\n  options.subres = {\n    partNumber: partNo,\n    uploadId\n  };\n  const params = this._objectRequestParams('PUT', name, options);\n  params.mime = options.mime;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    name,\n    etag: result.res.headers.etag,\n    res: result.res\n  };\n};\n\n/**\n * @param {String} name copy object name\n * @param {Object} sourceData\n *        {String} sourceData.sourceKey  the source object name\n *        {String} sourceData.sourceBucketName  the source bucket name\n *        {Number} sourceData.startOffset  data copy start byte offset, e.g: 0\n *        {Number} sourceData.endOffset  data copy end byte offset, e.g: 102400\n * @param {Object} options\n *        {Number} options.partSize\n */\nproto.multipartUploadCopy = async function multipartUploadCopy(name, sourceData, options = {}) {\n  this.resetCancelFlag();\n  const { versionId = null } = options;\n  const metaOpt = {\n    versionId\n  };\n  const objectMeta = await this._getObjectMeta(sourceData.sourceBucketName, sourceData.sourceKey, metaOpt);\n  const fileSize = objectMeta.res.headers['content-length'];\n  sourceData.startOffset = sourceData.startOffset || 0;\n  sourceData.endOffset = sourceData.endOffset || fileSize;\n\n  if (options.checkpoint && options.checkpoint.uploadId) {\n    return await this._resumeMultipartCopy(options.checkpoint, sourceData, options);\n  }\n\n  const minPartSize = 100 * 1024;\n\n  const copySize = sourceData.endOffset - sourceData.startOffset;\n  if (copySize < minPartSize) {\n    throw new Error(`copySize must not be smaller than ${minPartSize}`);\n  }\n\n  if (options.partSize && options.partSize < minPartSize) {\n    throw new Error(`partSize must not be smaller than ${minPartSize}`);\n  }\n\n  const init = await this.initMultipartUpload(name, options);\n  const { uploadId } = init;\n  const partSize = this._getPartSize(copySize, options.partSize);\n\n  const checkpoint = {\n    name,\n    copySize,\n    partSize,\n    uploadId,\n    doneParts: []\n  };\n\n  if (options && options.progress) {\n    await options.progress(0, checkpoint, init.res);\n  }\n\n  return await this._resumeMultipartCopy(checkpoint, sourceData, options);\n};\n\n/*\n * Resume multipart copy from checkpoint. The checkpoint will be\n * updated after each successful part copy.\n * @param {Object} checkpoint the checkpoint\n * @param {Object} options\n */\nproto._resumeMultipartCopy = async function _resumeMultipartCopy(checkpoint, sourceData, options) {\n  if (this.isCancel()) {\n    throw this._makeCancelEvent();\n  }\n  const { versionId = null } = options;\n  const metaOpt = {\n    versionId\n  };\n  const {\n    copySize, partSize, uploadId, doneParts, name\n  } = checkpoint;\n\n  const partOffs = this._divideMultipartCopyParts(copySize, partSize, sourceData.startOffset);\n  const numParts = partOffs.length;\n\n  const uploadPartCopyOptions = {\n    headers: {}\n  };\n\n  if (options.copyheaders) {\n    copy(options.copyheaders).to(uploadPartCopyOptions.headers);\n  }\n  if (versionId) {\n    copy(metaOpt).to(uploadPartCopyOptions);\n  }\n\n  const uploadPartJob = function uploadPartJob(self, partNo, source) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (!self.isCancel()) {\n          const pi = partOffs[partNo - 1];\n          const range = `${pi.start}-${pi.end - 1}`;\n\n          let result;\n          try {\n            result = await self.uploadPartCopy(name, uploadId, partNo, range, source, uploadPartCopyOptions);\n          } catch (error) {\n            if (error.status === 404) {\n              throw self._makeAbortEvent();\n            }\n            throw error;\n          }\n          if (!self.isCancel()) {\n            debug(`content-range ${result.res.headers['content-range']}`);\n            doneParts.push({\n              number: partNo,\n              etag: result.res.headers.etag\n            });\n            checkpoint.doneParts = doneParts;\n\n            if (options && options.progress) {\n              await options.progress(doneParts.length / numParts, checkpoint, result.res);\n            }\n          }\n        }\n        resolve();\n      } catch (err) {\n        err.partNum = partNo;\n        reject(err);\n      }\n    });\n  };\n\n  const all = Array.from(new Array(numParts), (x, i) => i + 1);\n  const done = doneParts.map(p => p.number);\n  const todo = all.filter(p => done.indexOf(p) < 0);\n  const defaultParallel = 5;\n  const parallel = options.parallel || defaultParallel;\n\n  if (this.checkBrowserAndVersion('Internet Explorer', '10') || parallel === 1) {\n    for (let i = 0; i < todo.length; i++) {\n      if (this.isCancel()) {\n        throw this._makeCancelEvent();\n      }\n      /* eslint no-await-in-loop: [0] */\n      await uploadPartJob(this, todo[i], sourceData);\n    }\n  } else {\n    // upload in parallel\n    const errors = await this._parallelNode(todo, parallel, uploadPartJob, sourceData);\n\n    const abortEvent = errors.find(err => err.name === 'abort');\n    if (abortEvent) throw abortEvent;\n\n    if (this.isCancel()) {\n      throw this._makeCancelEvent();\n    }\n\n    // check errors after all jobs are completed\n    if (errors && errors.length > 0) {\n      const err = errors[0];\n      err.message = `Failed to copy some parts with error: ${err.toString()} part_num: ${err.partNum}`;\n      throw err;\n    }\n  }\n\n  return await this.completeMultipartUpload(name, uploadId, doneParts, options);\n};\n\nproto._divideMultipartCopyParts = function _divideMultipartCopyParts(fileSize, partSize, startOffset) {\n  const numParts = Math.ceil(fileSize / partSize);\n\n  const partOffs = [];\n  for (let i = 0; i < numParts; i++) {\n    const start = (partSize * i) + startOffset;\n    const end = Math.min(start + partSize, fileSize + startOffset);\n\n    partOffs.push({\n      start,\n      end\n    });\n  }\n\n  return partOffs;\n};\n\n/**\n * Get Object Meta\n * @param {String} bucket  bucket name\n * @param {String} name   object name\n * @param {Object} options\n */\nproto._getObjectMeta = async function _getObjectMeta(bucket, name, options) {\n  const currentBucket = this.getBucket();\n  this.setBucket(bucket);\n  const data = await this.head(name, options);\n  this.setBucket(currentBucket);\n  return data;\n};\n","const { isArray } = require(\"./utils/isArray\");\n\nconst proto = exports;\n\nproto._parallelNode = async function _parallelNode(todo, parallel, fn, sourceData) {\n  const that = this;\n  // upload in parallel\n  const jobErr = [];\n  let jobs = [];\n  const tempBatch = todo.length / parallel;\n  const remainder = todo.length % parallel;\n  const batch = remainder === 0 ? tempBatch : ((todo.length - remainder) / parallel) + 1;\n  let taskIndex = 1;\n  for (let i = 0; i < todo.length; i++) {\n    if (that.isCancel()) {\n      break;\n    }\n\n    if (sourceData) {\n      jobs.push(fn(that, todo[i], sourceData));\n    } else {\n      jobs.push(fn(that, todo[i]));\n    }\n\n    if (jobs.length === parallel || (taskIndex === batch && i === (todo.length - 1))) {\n      try {\n        taskIndex += 1;\n        /* eslint no-await-in-loop: [0] */\n        await Promise.all(jobs);\n      } catch (err) {\n        jobErr.push(err);\n      }\n      jobs = [];\n    }\n  }\n\n  return jobErr;\n};\n\nproto._parallel = function _parallel(todo, parallel, jobPromise) {\n  const that = this;\n  return new Promise((resolve) => {\n    const _jobErr = [];\n    if (parallel <= 0 || !todo) {\n      resolve(_jobErr);\n      return;\n    }\n\n    function onlyOnce(fn) {\n      return function (...args) {\n        if (fn === null) throw new Error('Callback was already called.');\n        const callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n      };\n    }\n\n    function createArrayIterator(coll) {\n      let i = -1;\n      const len = coll.length;\n      return function next() {\n        return (++i < len && !that.isCancel()) ? { value: coll[i], key: i } : null;\n      };\n    }\n\n    const nextElem = createArrayIterator(todo);\n    let done = false;\n    let running = 0;\n    let looping = false;\n\n    function iterateeCallback(err, value) {\n      running -= 1;\n      if (err) {\n        done = true;\n        _jobErr.push(err);\n        resolve(_jobErr);\n      } else if (value === {} || (done && running <= 0)) {\n        done = true;\n        resolve(_jobErr);\n      } else if (!looping) {\n        /* eslint no-use-before-define: [0] */\n        if (that.isCancel()) {\n          resolve(_jobErr);\n        } else {\n          replenish();\n        }\n      }\n    }\n\n    function iteratee(value, callback) {\n      jobPromise(value).then((result) => {\n        callback(null, result);\n      }).catch((err) => {\n        callback(err);\n      });\n    }\n\n    function replenish() {\n      looping = true;\n      while (running < parallel && !done && !that.isCancel()) {\n        const elem = nextElem();\n        if (elem === null || _jobErr.length > 0) {\n          done = true;\n          if (running <= 0) {\n            resolve(_jobErr);\n          }\n          return;\n        }\n        running += 1;\n        iteratee(elem.value, onlyOnce(iterateeCallback));\n      }\n      looping = false;\n    }\n\n    replenish();\n  });\n};\n\n/**\n * cancel operation, now can use with multipartUpload\n * @param {Object} abort\n *        {String} anort.name object key\n *        {String} anort.uploadId upload id\n *        {String} anort.options timeout\n */\nproto.cancel = function cancel(abort) {\n  this.options.cancelFlag = true;\n\n  if (isArray(this.multipartUploadStreams)) {\n    this.multipartUploadStreams.forEach(_ => {\n      if (_.destroyed === false) {\n        const err = {\n          name: 'cancel',\n          message: 'cancel'\n        };\n        _.destroy(err);\n      }\n    });\n  }\n  this.multipartUploadStreams = [];\n  if (abort) {\n    this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);\n  }\n};\n\nproto.isCancel = function isCancel() {\n  return this.options.cancelFlag;\n};\n\nproto.resetCancelFlag = function resetCancelFlag() {\n  this.options.cancelFlag = false;\n};\n\nproto._stop = function _stop() {\n  this.options.cancelFlag = true;\n};\n\n// cancel is not error , so create an object\nproto._makeCancelEvent = function _makeCancelEvent() {\n  const cancelEvent = {\n    status: 0,\n    name: 'cancel'\n  };\n  return cancelEvent;\n};\n\n// abort is not error , so create an object\nproto._makeAbortEvent = function _makeAbortEvent() {\n  const abortEvent = {\n    status: 0,\n    name: 'abort',\n    message: 'upload task has been abort'\n  };\n  return abortEvent;\n};\n","const copy = require('copy-to');\nconst callback = require('./callback');\nconst { deepCopyWith } = require('./utils/deepCopy');\nconst { isBuffer } = require('./utils/isBuffer');\n\nconst proto = exports;\n\n/**\n * List the on-going multipart uploads\n * https://help.aliyun.com/document_detail/31997.html\n * @param {Object} options\n * @return {Array} the multipart uploads\n */\nproto.listUploads = async function listUploads(query, options) {\n  options = options || {};\n  const opt = {};\n  copy(options).to(opt);\n  opt.subres = 'uploads';\n  const params = this._objectRequestParams('GET', '', opt);\n  params.query = query;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n  let uploads = result.data.Upload || [];\n  if (!Array.isArray(uploads)) {\n    uploads = [uploads];\n  }\n  uploads = uploads.map(up => ({\n    name: up.Key,\n    uploadId: up.UploadId,\n    initiated: up.Initiated\n  }));\n\n  return {\n    res: result.res,\n    uploads,\n    bucket: result.data.Bucket,\n    nextKeyMarker: result.data.NextKeyMarker,\n    nextUploadIdMarker: result.data.NextUploadIdMarker,\n    isTruncated: result.data.IsTruncated === 'true'\n  };\n};\n\n/**\n * List the done uploadPart parts\n * @param {String} name object name\n * @param {String} uploadId multipart upload id\n * @param {Object} query\n * {Number} query.max-parts The maximum part number in the response of the OSS. Default value: 1000\n * {Number} query.part-number-marker Starting position of a specific list.\n * {String} query.encoding-type Specify the encoding of the returned content and the encoding type.\n * @param {Object} options\n * @return {Object} result\n */\nproto.listParts = async function listParts(name, uploadId, query, options) {\n  options = options || {};\n  const opt = {};\n  copy(options).to(opt);\n  opt.subres = {\n    uploadId\n  };\n  const params = this._objectRequestParams('GET', name, opt);\n  params.query = query;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res,\n    uploadId: result.data.UploadId,\n    bucket: result.data.Bucket,\n    name: result.data.Key,\n    partNumberMarker: result.data.PartNumberMarker,\n    nextPartNumberMarker: result.data.NextPartNumberMarker,\n    maxParts: result.data.MaxParts,\n    isTruncated: result.data.IsTruncated,\n    parts: result.data.Part || []\n  };\n};\n\n/**\n * Abort a multipart upload transaction\n * @param {String} name the object name\n * @param {String} uploadId the upload id\n * @param {Object} options\n */\nproto.abortMultipartUpload = async function abortMultipartUpload(name, uploadId, options) {\n  this._stop();\n  options = options || {};\n  const opt = {};\n  copy(options).to(opt);\n  opt.subres = { uploadId };\n  const params = this._objectRequestParams('DELETE', name, opt);\n  params.successStatuses = [204];\n\n  const result = await this.request(params);\n  return {\n    res: result.res\n  };\n};\n\n/**\n * Initiate a multipart upload transaction\n * @param {String} name the object name\n * @param {Object} options\n * @return {String} upload id\n */\nproto.initMultipartUpload = async function initMultipartUpload(name, options) {\n  options = options || {};\n  const opt = {};\n  copy(options).to(opt);\n  opt.headers = opt.headers || {};\n  this._convertMetaToHeaders(options.meta, opt.headers);\n\n  opt.subres = 'uploads';\n  const params = this._objectRequestParams('POST', name, opt);\n  params.mime = options.mime;\n  params.xmlResponse = true;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  return {\n    res: result.res,\n    bucket: result.data.Bucket,\n    name: result.data.Key,\n    uploadId: result.data.UploadId\n  };\n};\n\n/**\n * Upload a part in a multipart upload transaction\n * @param {String} name the object name\n * @param {String} uploadId the upload id\n * @param {Integer} partNo the part number\n * @param {File} file upload File, whole File\n * @param {Integer} start  part start bytes  e.g: 102400\n * @param {Integer} end  part end bytes  e.g: 204800\n * @param {Object} options\n */\nproto.uploadPart = async function uploadPart(name, uploadId, partNo, file, start, end, options) {\n  const data = {\n    stream: this._createStream(file, start, end),\n    size: end - start\n  };\n  return await this._uploadPart(name, uploadId, partNo, data, options);\n};\n\n/**\n * Complete a multipart upload transaction\n * @param {String} name the object name\n * @param {String} uploadId the upload id\n * @param {Array} parts the uploaded parts, each in the structure:\n *        {Integer} number partNo\n *        {String} etag  part etag  uploadPartCopy result.res.header.etag\n * @param {Object} options\n *         {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64\n *         {String} options.callback.url  the OSS sends a callback request to this URL\n *         {String} options.callback.host  The host header value for initiating callback requests\n *         {String} options.callback.body  The value of the request body when a callback is initiated\n *         {String} options.callback.contentType  The Content-Type of the callback requests initiatiated\n *         {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:\n *                   customValue = {\n *                     key1: 'value1',\n *                     key2: 'value2'\n *                   }\n */\nproto.completeMultipartUpload = async function completeMultipartUpload(name, uploadId, parts, options) {\n  const completeParts = parts.concat().sort((a, b) => a.number - b.number)\n    .filter((item, index, arr) => !index || item.number !== arr[index - 1].number);\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<CompleteMultipartUpload>\\n';\n  for (let i = 0; i < completeParts.length; i++) {\n    const p = completeParts[i];\n    xml += '<Part>\\n';\n    xml += `<PartNumber>${p.number}</PartNumber>\\n`;\n    xml += `<ETag>${p.etag}</ETag>\\n`;\n    xml += '</Part>\\n';\n  }\n  xml += '</CompleteMultipartUpload>';\n\n  options = options || {};\n  let opt = {};\n  opt = deepCopyWith(options, (_) => {\n    if (isBuffer(_)) return null;\n  });\n  if (opt.headers) delete opt.headers['x-oss-server-side-encryption'];\n  opt.subres = { uploadId };\n\n  const params = this._objectRequestParams('POST', name, opt);\n  callback.encodeCallback(params, opt);\n  params.mime = 'xml';\n  params.content = xml;\n\n  if (!(params.headers && params.headers['x-oss-callback'])) {\n    params.xmlResponse = true;\n  }\n  params.successStatuses = [200];\n  const result = await this.request(params);\n\n  const ret = {\n    res: result.res,\n    bucket: params.bucket,\n    name,\n    etag: result.res.headers.etag\n  };\n\n  if (params.headers && params.headers['x-oss-callback']) {\n    ret.data = JSON.parse(result.data.toString());\n  }\n\n  return ret;\n};\n\n/**\n * Upload a part in a multipart upload transaction\n * @param {String} name the object name\n * @param {String} uploadId the upload id\n * @param {Integer} partNo the part number\n * @param {Object} data the body data\n * @param {Object} options\n */\nproto._uploadPart = async function _uploadPart(name, uploadId, partNo, data, options) {\n  options = options || {};\n  const opt = {};\n  copy(options).to(opt);\n  opt.headers = {\n    'Content-Length': data.size\n  };\n\n  opt.subres = {\n    partNumber: partNo,\n    uploadId\n  };\n  const params = this._objectRequestParams('PUT', name, opt);\n  params.mime = opt.mime;\n  params.stream = data.stream;\n  params.successStatuses = [200];\n\n  const result = await this.request(params);\n\n  if (!result.res.headers.etag) {\n    throw new Error(\n      'Please set the etag of expose-headers in OSS \\n https://help.aliyun.com/document_detail/32069.html'\n    );\n  }\n\n  data.stream = null;\n  params.stream = null;\n  return {\n    name,\n    etag: result.res.headers.etag,\n    res: result.res\n  };\n};\n","\n\n/* istanbul ignore next */\nmodule.exports = function (OssClient) {\n  /* istanbul ignore next */\n//   function objectRequestParams(method, name, options) {\n//     options = options || {};\n//     name = this._objectName(name);\n//     const authResource = `/${this.options.bucket}/${name}`;\n//     const params = {\n//       name,\n//       method,\n//       host: this.options.imageHost,\n//       resource: `/${name}`,\n//       timeout: options.timeout,\n//       authResource,\n//       ctx: options.ctx\n//     };\n//     if (options.headers) {\n//       params.headers = options.headers;\n//     }\n//     return params;\n//   }\n\n  function ImageClient(options) {\n    if (!(this instanceof ImageClient)) {\n      return new ImageClient(options);\n    }\n    if (!options.bucket) {\n      throw new Error('require bucket for image service instance');\n    }\n    if (!options.imageHost) {\n      throw new Error('require imageHost for image service instance');\n    }\n\n    options.endpoint = options.imageHost;\n    this.ossClient = new OssClient(options);\n    this.ossClient.options.imageHost = options.imageHost;\n    // this.ossClient._objectRequestParams = objectRequestParams;\n  }\n\n  /**\n   * Image operations\n   */\n\n  ImageClient.prototype.get = async function get(name, file, options) {\n    return await this.ossClient.get(name, file, options);\n  };\n\n  ImageClient.prototype.getStream = async function getStream(name, options) {\n    return await this.ossClient.getStream(name, options);\n  };\n\n  ImageClient.prototype.getExif = async function getExif(name, options) {\n    const params = this.ossClient._objectRequestParams('GET', `${name}@exif`, options);\n    params.successStatuses = [200];\n\n    let result = await this.ossClient.request(params);\n    result = await this._parseResponse(result);\n    return {\n      res: result.res,\n      data: result.data\n    };\n  };\n\n  ImageClient.prototype.getInfo = async function getInfo(name, options) {\n    const params = this.ossClient._objectRequestParams('GET', `${name}@infoexif`, options);\n    params.successStatuses = [200];\n\n    let result = await this.ossClient.request(params);\n    result = await this._parseResponse(result);\n    return {\n      res: result.res,\n      data: result.data\n    };\n  };\n\n  ImageClient.prototype.putStyle = async function putStyle(styleName, style, options) {\n    const params = this.ossClient._objectRequestParams('PUT', `/?style&styleName=${styleName}`, options);\n    params.successStatuses = [200];\n    params.content = `${'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' +\n      '<Style><Content>'}${style}</Content></Style>`;\n\n    let result = await this.ossClient.request(params);\n    result = await this._parseResponse(result);\n    return {\n      res: result.res,\n      data: result.data\n    };\n  };\n\n  ImageClient.prototype.getStyle = async function getStyle(styleName, options) {\n    const params = this.ossClient._objectRequestParams('GET', `/?style&styleName=${styleName}`, options);\n    params.successStatuses = [200];\n\n    let result = await this.ossClient.request(params);\n    result = await this._parseResponse(result);\n    return {\n      res: result.res,\n      data: result.data\n    };\n  };\n\n  ImageClient.prototype.listStyle = async function listStyle(options) {\n    const params = this.ossClient._objectRequestParams('GET', '/?style', options);\n    params.successStatuses = [200];\n\n    let result = await this.ossClient.request(params);\n    result = await this._parseResponse(result);\n    return {\n      res: result.res,\n      data: result.data.Style\n    };\n  };\n\n  ImageClient.prototype.deleteStyle = async function deleteStyle(styleName, options) {\n    const params = this.ossClient._objectRequestParams('DELETE', `/?style&styleName=${styleName}`, options);\n    params.successStatuses = [204];\n\n    const result = await this.ossClient.request(params);\n    return {\n      res: result.res\n    };\n  };\n\n  ImageClient.prototype.signatureUrl = function signatureUrl(name) {\n    return this.ossClient.signatureUrl(name);\n  };\n\n  ImageClient.prototype._parseResponse = async function _parseResponse(result) {\n    const str = result.data.toString();\n    const type = result.res.headers['content-type'];\n\n    if (type === 'application/json') {\n      const data = JSON.parse(str);\n      result.data = {};\n      if (data) {\n        Object.keys(data).forEach((key) => {\n          result.data[key] = parseFloat(data[key].value, 10) || data[key].value;\n        });\n      }\n    } else if (type === 'application/xml') {\n      result.data = await this.ossClient.parseXML(str);\n    }\n    return result;\n  };\n\n  return ImageClient;\n};\n","\nconst Base = require('sdk-base');\nconst util = require('util');\nconst ready = require('get-ready');\nconst copy = require('copy-to');\nconst currentIP = require('address').ip();\n\nconst RR = 'roundRobin';\nconst MS = 'masterSlave';\n\nmodule.exports = function (OssClient) {\n  function Client(options) {\n    if (!(this instanceof Client)) {\n      return new Client(options);\n    }\n\n    if (!options || !Array.isArray(options.cluster)) {\n      throw new Error('require options.cluster to be an array');\n    }\n\n    Base.call(this);\n\n    this.clients = [];\n    this.availables = {};\n\n    for (let i = 0; i < options.cluster.length; i++) {\n      const opt = options.cluster[i];\n      copy(options).pick('timeout', 'agent', 'urllib').to(opt);\n      this.clients.push(new OssClient(opt));\n      this.availables[i] = true;\n    }\n\n    this.schedule = options.schedule || RR;\n    // only read from master, default is false\n    this.masterOnly = !!options.masterOnly;\n    this.index = 0;\n\n    const heartbeatInterval = options.heartbeatInterval || 10000;\n    this._checkAvailableLock = false;\n    this._timerId = this._deferInterval(this._checkAvailable.bind(this, true), heartbeatInterval);\n    this._ignoreStatusFile = options.ignoreStatusFile || false;\n    this._init();\n  }\n\n  util.inherits(Client, Base);\n  const proto = Client.prototype;\n  ready.mixin(proto);\n\n  const GET_METHODS = [\n    'head',\n    'get',\n    'getStream',\n    'list',\n    'getACL'\n  ];\n\n  const PUT_METHODS = [\n    'put',\n    'putStream',\n    'delete',\n    'deleteMulti',\n    'copy',\n    'putMeta',\n    'putACL'\n  ];\n\n  GET_METHODS.forEach((method) => {\n    proto[method] = async function (...args) {\n      const client = this.chooseAvailable();\n      let lastError;\n      try {\n        return await client[method](...args);\n      } catch (err) {\n        if (err.status && err.status >= 200 && err.status < 500) {\n          // 200 ~ 499 belong to normal response, don't try again\n          throw err;\n        }\n        // < 200 || >= 500 need to retry from other cluser node\n        lastError = err;\n      }\n\n      for (let i = 0; i < this.clients.length; i++) {\n        const c = this.clients[i];\n        if (c !== client) {\n          try {\n            return await c[method].apply(client, args);\n          } catch (err) {\n            if (err.status && err.status >= 200 && err.status < 500) {\n              // 200 ~ 499 belong to normal response, don't try again\n              throw err;\n            }\n            // < 200 || >= 500 need to retry from other cluser node\n            lastError = err;\n          }\n        }\n      }\n\n      lastError.message += ' (all clients are down)';\n      throw lastError;\n    };\n  });\n\n  // must cluster node write success\n  PUT_METHODS.forEach((method) => {\n    proto[method] = async function (...args) {\n      const res = await Promise.all(this.clients.map(client => client[method](...args)));\n      return res[0];\n    };\n  });\n\n  proto.signatureUrl = function signatureUrl(/* name */...args) {\n    const client = this.chooseAvailable();\n    return client.signatureUrl(...args);\n  };\n\n  proto.getObjectUrl = function getObjectUrl(/* name, baseUrl */...args) {\n    const client = this.chooseAvailable();\n    return client.getObjectUrl(...args);\n  };\n\n  proto._init = function _init() {\n    const that = this;\n    (async () => {\n      await that._checkAvailable(that._ignoreStatusFile);\n      that.ready(true);\n    })().catch((err) => {\n      that.emit('error', err);\n    });\n  };\n\n  proto._checkAvailable = async function _checkAvailable(ignoreStatusFile) {\n    const name = `._ali-oss/check.status.${currentIP}.txt`;\n    if (!ignoreStatusFile) {\n      // only start will try to write the file\n      await this.put(name, Buffer.from(`check available started at ${Date()}`));\n    }\n\n    if (this._checkAvailableLock) {\n      return;\n    }\n    this._checkAvailableLock = true;\n    const downStatusFiles = [];\n    for (let i = 0; i < this.clients.length; i++) {\n      const client = this.clients[i];\n      // check 3 times\n      let available = await this._checkStatus(client, name);\n      if (!available) {\n        // check again\n        available = await this._checkStatus(client, name);\n      }\n      if (!available) {\n        // check again\n        /* eslint no-await-in-loop: [0] */\n        available = await this._checkStatus(client, name);\n        if (!available) {\n          downStatusFiles.push(client._objectUrl(name));\n        }\n      }\n      this.availables[i] = available;\n    }\n    this._checkAvailableLock = false;\n\n    if (downStatusFiles.length > 0) {\n      const err = new Error(`${downStatusFiles.length} data node down, please check status file: ${downStatusFiles.join(', ')}`);\n      err.name = 'CheckAvailableError';\n      this.emit('error', err);\n    }\n  };\n\n  proto._checkStatus = async function _checkStatus(client, name) {\n    let available = true;\n    try {\n      await client.head(name);\n    } catch (err) {\n      // 404 will be available too\n      if (!err.status || err.status >= 500 || err.status < 200) {\n        available = false;\n      }\n    }\n    return available;\n  };\n\n  proto.chooseAvailable = function chooseAvailable() {\n    if (this.schedule === MS) {\n      // only read from master\n      if (this.masterOnly) {\n        return this.clients[0];\n      }\n      for (let i = 0; i < this.clients.length; i++) {\n        if (this.availables[i]) {\n          return this.clients[i];\n        }\n      }\n      // all down, try to use this first one\n      return this.clients[0];\n    }\n\n    // RR\n    let n = this.clients.length;\n    while (n > 0) {\n      const i = this._nextRRIndex();\n      if (this.availables[i]) {\n        return this.clients[i];\n      }\n      n--;\n    }\n    // all down, try to use this first one\n    return this.clients[0];\n  };\n\n  proto._nextRRIndex = function _nextRRIndex() {\n    const index = this.index++;\n    if (this.index >= this.clients.length) {\n      this.index = 0;\n    }\n    return index;\n  };\n\n  proto._error = function error(err) {\n    if (err) throw err;\n  };\n\n  proto._createCallback = function _createCallback(ctx, gen, cb) {\n    return () => {\n      cb = cb || this._error;\n      gen.call(ctx).then(() => {\n        cb();\n      }, cb);\n    };\n  };\n  proto._deferInterval = function _deferInterval(gen, timeout, cb) {\n    return setInterval(this._createCallback(this, gen, cb), timeout);\n  };\n\n  proto.close = function close() {\n    clearInterval(this._timerId);\n    this._timerId = null;\n  };\n\n  return Client;\n};\n","\nconst debug = require('debug')('ali-oss:sts');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\nconst copy = require('copy-to');\nconst AgentKeepalive = require('agentkeepalive');\nconst is = require('is-type-of');\nconst ms = require('humanize-ms');\nconst urllib = require('urllib');\n\nconst globalHttpAgent = new AgentKeepalive();\n\n\nfunction STS(options) {\n  if (!(this instanceof STS)) {\n    return new STS(options);\n  }\n\n  if (!options\n    || !options.accessKeyId\n    || !options.accessKeySecret) {\n    throw new Error('require accessKeyId, accessKeySecret');\n  }\n\n  this.options = {\n    endpoint: options.endpoint || 'https://sts.aliyuncs.com',\n    format: 'JSON',\n    apiVersion: '2015-04-01',\n    sigMethod: 'HMAC-SHA1',\n    sigVersion: '1.0',\n    timeout: '60s'\n  };\n  copy(options).to(this.options);\n\n  // support custom agent and urllib client\n  if (this.options.urllib) {\n    this.urllib = this.options.urllib;\n  } else {\n    this.urllib = urllib;\n    this.agent = this.options.agent || globalHttpAgent;\n  }\n}\n\nmodule.exports = STS;\n\nconst proto = STS.prototype;\n\n/**\n * STS opertaions\n */\n\nproto.assumeRole = async function assumeRole(role, policy, expiration, session, options) {\n  const opts = this.options;\n  const params = {\n    Action: 'AssumeRole',\n    RoleArn: role,\n    RoleSessionName: session || 'app',\n    DurationSeconds: expiration || 3600,\n\n    Format: opts.format,\n    Version: opts.apiVersion,\n    AccessKeyId: opts.accessKeyId,\n    SignatureMethod: opts.sigMethod,\n    SignatureVersion: opts.sigVersion,\n    SignatureNonce: Math.random(),\n    Timestamp: new Date().toISOString()\n  };\n\n  if (policy) {\n    let policyStr;\n    if (is.string(policy)) {\n      try {\n        policyStr = JSON.stringify(JSON.parse(policy));\n      } catch (err) {\n        throw new Error(`Policy string is not a valid JSON: ${err.message}`);\n      }\n    } else {\n      policyStr = JSON.stringify(policy);\n    }\n    params.Policy = policyStr;\n  }\n\n  const signature = this._getSignature('POST', params, opts.accessKeySecret);\n  params.Signature = signature;\n\n  const reqUrl = opts.endpoint;\n  const reqParams = {\n    agent: this.agent,\n    timeout: ms((options && options.timeout) || opts.timeout),\n    method: 'POST',\n    content: querystring.stringify(params),\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    ctx: options && options.ctx\n  };\n\n  const result = await this.urllib.request(reqUrl, reqParams);\n  debug(\n    'response %s %s, got %s, headers: %j',\n    reqParams.method, reqUrl, result.status, result.headers\n  );\n\n  if (Math.floor(result.status / 100) !== 2) {\n    const err = await this._requestError(result);\n    err.params = reqParams;\n    throw err;\n  }\n  result.data = JSON.parse(result.data);\n\n  return {\n    res: result.res,\n    credentials: result.data.Credentials\n  };\n};\n\nproto._requestError = async function _requestError(result) {\n  const err = new Error();\n  err.status = result.status;\n\n  try {\n    const resp = await JSON.parse(result.data) || {};\n    err.code = resp.Code;\n    err.message = `${resp.Code}: ${resp.Message}`;\n    err.requestId = resp.RequestId;\n  } catch (e) {\n    err.message = `UnknownError: ${String(result.data)}`;\n  }\n\n  return err;\n};\n\nproto._getSignature = function _getSignature(method, params, key) {\n  const that = this;\n  const canoQuery = Object.keys(params).sort().map(k => `${that._escape(k)}=${that._escape(params[k])}`).join('&');\n\n  const stringToSign =\n      `${method.toUpperCase()\n      }&${this._escape('/')\n      }&${this._escape(canoQuery)}`;\n\n  debug('string to sign: %s', stringToSign);\n\n  let signature = crypto.createHmac('sha1', `${key}&`);\n  signature = signature.update(stringToSign).digest('base64');\n\n  debug('signature: %s', signature);\n\n  return signature;\n};\n\n/**\n * Since `encodeURIComponent` doesn't encode '*', which causes\n * 'SignatureDoesNotMatch'. We need do it ourselves.\n */\nproto._escape = function _escape(str) {\n  return encodeURIComponent(str)\n    .replace(/!/g, '%21')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29')\n    .replace(/\\*/g, '%2A');\n};\n"]}